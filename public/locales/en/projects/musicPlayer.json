{
  "shortDesc": "A music player app for easy music listening.",
  "technologies": ["React Native", "Expo", "SQLite", "Node.js"],
  "badge": "Offline-First",
  "role": "Personal Development",
  "detail": {
    "hero": {
      "title": "Music Player",
      "tagline": "Offline-First √ó Custom Tags √ó Data Backup",
      "description": "A cross-platform music management system designed to solve playback interruptions, complex filtering, and data backup pain points.",
      "summary": {
        "problem": {
          "title": "Challenge",
          "desc": "Existing players <highlight>lack advanced filtering</highlight> and music interrupts on unstable networks"
        },
        "solution": {
          "title": "Solution",
          "desc": "Developed offline-first architecture with SQLite database and large file transfer engine"
        },
        "impact": {
          "title": "Impact",
          "desc": "Achieved <highlight>100% offline playback</highlight> and <highlight>multi-dimensional filtering</highlight>"
        }
      }
    },
    "overview": {
      "duration": "About 2 Months (Core Dev)",
      "team": "Personal Development",
      "projectType": "Personal Project ¬∑ Mobile Full-Stack",
      "focus": ["Database Migration", "Playback State Machine", "File System Management"],
      "mainTechs": ["React Native", "Expo", "SQLite", "Node.js"],
      "platforms": ["iOS"]
    },
    "challenges": [
      {
        "id": 1,
        "title": "Conditional Playback Lock - Filter Without Interruption",
        "symptom": "UI updates caused unintended player re-initialization",
        "rootCause": "View layer tightly coupled with native player instance, filtering triggers player reset",
        "impact": "User experience interrupted, need to reselect song",
        "badge": "Stability: 100%",
        "metrics": {
          "label": "Playback Interruption Rate",
          "before": "100%",
          "after": "0%"
        },
        "filePath": "app/(tabs)/index.tsx",
        "codeSnippet": "if (list.length > 0 && !player.playing) {\n  const filePath = await getDocumentFile(\n    `audio/${list[0].fileName}`\n  );\n  if (filePath) {\n    player.replace(filePath.uri);\n    setAudioId(list[0]?.id);\n  }\n}\nsetAudios(list);",
        "highlightTerms": ["!player.playing"],
        "solution": {
          "approach": "Conditional Playback Lock (!player.playing)",
          "details": [
            "Use !player.playing to decouple view layer from native player instance",
            "Check playback state before filtering, only reset player when not playing",
            "When playing, only update list view to ensure continuous playback"
          ],
          "result": "Music continues playing during tag filtering, view and player fully decoupled",
          "category": "State Management"
        }
      },
      {
        "id": 2,
        "title": "SQLite Migration - Version Control",
        "symptom": "App updates with schema changes may cause crashes",
        "rootCause": "Lack of version control mechanism to track database schema changes",
        "impact": "Users may lose data or experience crashes after upgrade",
        "badge": "Data Integrity: 100%",
        "metrics": {
          "label": "Upgrade Data Loss Rate",
          "before": "Risk",
          "after": "0%"
        },
        "filePath": "utils/sqlite/init.ts",
        "codeSnippet": "const DATABASE_VERSION = 2;\n\nconst currentDbVersion = (\n  await db.getFirstAsync<{ user_version: number }>(\n    \"PRAGMA user_version\"\n  )\n)?.user_version ?? null;\n\nif (currentDbVersion < DATABASE_VERSION) {\n  await runMigrations(currentDbVersion);\n}\n\nawait db.execAsync(\n  `PRAGMA user_version = ${DATABASE_VERSION}`\n);",
        "highlightTerms": ["PRAGMA user_version", "DATABASE_VERSION"],
        "solution": {
          "approach": "PRAGMA user_version Versioning",
          "details": [
            "Use PRAGMA user_version to track database version",
            "Check version number on app startup",
            "Execute corresponding migration scripts based on version diff",
            "Update user_version after migration completes"
          ],
          "result": "Supports smooth database upgrades, user data preserved",
          "category": "Database Management"
        }
      },
      {
        "id": 3,
        "title": "High-Stability Download Engine - Large File Transfer",
        "symptom": "UI blocks during large file downloads, no progress tracking",
        "rootCause": "Native download API lacks progress callback and non-blocking transfer mechanism",
        "impact": "Users cannot track download status, poor experience",
        "badge": "UX Feedback: Real-time",
        "metrics": {
          "label": "Progress Tracking",
          "before": "None",
          "after": "Real-time"
        },
        "filePath": "utils/Apis/File/index.ts",
        "codeSnippet": "const downloadResumable = FileSystem\n  .createDownloadResumable(\n    `${this.origin}/${remotePath}`,\n    localTempPath,\n    {},\n    (progress) => onProgress?.({\n      progress: progress.totalBytesWritten /\n        progress.totalBytesExpectedToWrite\n    })\n  );\n\nconst result = await downloadResumable\n  .downloadAsync();",
        "highlightTerms": ["createDownloadResumable", "onProgress"],
        "solution": {
          "approach": "High-Stability Download Engine",
          "details": [
            "Wrap createDownloadResumable for non-blocking transfer",
            "Real-time progress callback (onProgress) updates UI",
            "UI layer decoupled from download layer, large file transfer doesn't block main thread"
          ],
          "result": "Real-time progress tracking, UI non-blocking large file transfer",
          "category": "File Management"
        }
      }
    ],
    "gallery": {
      "tabs": {
        "demo": "Demo",
        "screenshots": "App Screenshots"
      },
      "demo": {
        "v1": {
          "title": "Music Filtering",
          "desc": "Demonstrates multi-condition filtering while keeping music playing"
        },
        "v2": {
          "title": "Music Detail Modal",
          "desc": "Tap song to show details including cover, artist, album"
        },
        "v3": {
          "title": "Batch Audio Download",
          "desc": "Demonstrates batch audio download with progress tracking"
        },
        "v4": {
          "title": "Music Upload",
          "desc": "Demonstrates music upload"
        }
      },
      "screenshots": {
        "s1": {
          "title": "Launch Screen - Light Theme",
          "desc": "App launch branding screen"
        },
        "s2": {
          "title": "Launch Screen - Dark Theme",
          "desc": "Launch screen with system dark mode support"
        },
        "s3": {
          "title": "Home Screen - Light Theme",
          "desc": "Music list with filter tags and playback controls"
        },
        "s4": {
          "title": "Home Screen - Dark Theme",
          "desc": "Dark mode music list interface"
        },
        "s5": {
          "title": "Profile Screen - Light Theme",
          "desc": "User settings and backup features"
        },
        "s6": {
          "title": "Profile Screen - Dark Theme",
          "desc": "Dark mode settings page"
        }
      }
    },
    "roadmap": {
      "title": "Future Roadmap & Optimization",
      "categories": [
        {
          "icon": "‚òÅÔ∏è",
          "title": "Cloud Ecosystem",
          "items": [
            "Google Drive Sync (Private Cloud Asset Management)",
            "Smart Prefetching (Background downloading for next track)",
            "Automated SQLite Backup"
          ]
        },
        {
          "icon": "‚ö°",
          "title": "Native Experience",
          "items": ["Robust Background Playback Service", "Advanced Playback Control (Loop modes, Sleep timer)"]
        },
        {
          "icon": "üè∑Ô∏è",
          "title": "Data Flexibility",
          "items": ["Dynamic Tagging System (Custom filters)", "Modify music Tagging"]
        }
      ]
    },
    "disclaimer": "This project is an open-source initiative for educational purposes. It focuses on technical implementation of offline-first architecture and private cloud synchronization. All media assets shown are for demonstration only."
  }
}

