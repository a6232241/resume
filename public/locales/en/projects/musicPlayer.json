{
  "title": "Music Player",
  "shortDesc": "A music player app for easy music listening.",
  "technologies": ["React Native", "Expo", "SQLite", "Node.js"],
  "badge": "Offline-First",
  "role": "Personal Development",
  "detail": {
    "hero": {
      "title": "Music Player",
      "tagline": "Offline-First √ó Custom Tags √ó Data Backup",
      "summary": {
        "problem": {
          "title": "Challenge",
          "desc": "Existing players <highlight>lack advanced filtering</highlight> and music interrupts on unstable networks"
        },
        "solution": {
          "title": "Solution",
          "desc": "Developed offline-first architecture with SQLite database and large file transfer engine"
        },
        "impact": {
          "title": "Impact",
          "desc": "Achieved <highlight>100% offline playback</highlight> and <highlight>multi-dimensional filtering</highlight>"
        }
      }
    },
    "overview": {
      "description": "A cross-platform music management system designed to solve playback interruptions, complex filtering, and data backup pain points.",
      "duration": "About 2 Months (Core Dev)",
      "team": "Personal Development",
      "projectType": "Personal Project ¬∑ Mobile Full-Stack",
      "focus": ["Database Migration", "Playback State Machine", "File System Management"],
      "mainTechs": ["React Native", "Expo", "SQLite", "Node.js"],
      "platforms": ["iOS"]
    },
    "technicalSpotlight": [
      {
        "id": "conditional-playback-lock",
        "title": "Conditional Playback Lock - Filter Without Interruption",
        "role": "React Native Developer",
        "icon": "play-circle",
        "summary": "Decoupled view layer from native player instance using !player.playing to ensure continuous playback during filtering.",
        "tags": ["State Management", "Audio Playback", "UX"],
        "challenge": {
          "title": "Challenge",
          "items": [
            "UI updates caused unintended player re-initialization",
            "View layer was tightly coupled with native player instance; filtering triggered player reset",
            "User experience was interrupted, forcing users to reselect songs"
          ]
        },
        "analysis": {
          "title": "Analysis",
          "items": [
            "Analyzed React Native lifecycle impact on native player instance",
            "Confirmed that re-renders triggered by filtering operations caused Context reset"
          ]
        },
        "decisions": {
          "title": "Engineering Decisions",
          "items": [
            {
              "title": "Playback State Management Strategy",
              "items": [
                {
                  "title": "Conditional Playback Lock (!player.playing)",
                  "desc": "Pros: Decouples view layer from native player instance. Checks playback state before filtering and only resets player when not playing.",
                  "highlight": true
                },
                {
                  "title": "Reset Player on Every Filter",
                  "desc": "Cons: Interrupts user experience; music cannot continue playing in the background."
                }
              ]
            }
          ]
        },
        "result": {
          "title": "Result",
          "items": [
            "Music continues playing during tag filtering; view and player are fully decoupled",
            "Reduced playback interruption rate to 0%"
          ]
        },
        "codeSnippetTabs": [
          {
            "label": "Logic",
            "title": "Conditional Playback Lock",
            "language": "typescript",
            "code": "if (list.length > 0 && !player.playing) {\n  const filePath = await getDocumentFile(\n    `audio/${list[0].fileName}`\n  );\n  if (filePath) {\n    player.replace(filePath.uri);\n    setAudioId(list[0]?.id);\n  }\n}\nsetAudios(list);",
            "highlights": [1],
            "tooltips": [{ "line": 1, "content": "Initialize only when not playing" }]
          }
        ]
      },
      {
        "id": "sqlite-migration",
        "title": "SQLite Migration - Version Control",
        "role": "React Native Developer",
        "icon": "database",
        "summary": "Implemented PRAGMA user_version version control mechanism to support smooth database upgrades.",
        "tags": ["SQLite", "Database Migration", "Data Integrity"],
        "challenge": {
          "title": "Challenge",
          "items": [
            "App updates with schema changes could cause crashes",
            "Lack of version control mechanism made it impossible to track database schema changes",
            "Users risked losing data or experiencing crashes after upgrades"
          ]
        },
        "analysis": {
          "title": "Analysis",
          "items": [
            "Evaluated different SQLite version management schemes",
            "Researched expo-sqlite migration support and native PRAGMA commands"
          ]
        },
        "decisions": {
          "title": "Engineering Decisions",
          "items": [
            {
              "title": "Database Upgrade Strategy",
              "items": [
                {
                  "title": "PRAGMA user_version Versioning",
                  "desc": "Pros: Directly utilizes SQLite built-in versioning, independent of extra tables, and allows precise control over migration flow.",
                  "highlight": true
                },
                {
                  "title": "No Version Control",
                  "desc": "Cons: Schema changes require manual database deletion, resulting in user data loss."
                }
              ]
            }
          ]
        },
        "result": {
          "title": "Result",
          "items": [
            "Supports smooth database upgrades with full user data preservation",
            "Eliminated crash risks caused by schema changes"
          ]
        },
        "codeSnippetTabs": [
          {
            "label": "Migration",
            "title": "Database Version Check & Migration",
            "language": "typescript",
            "code": "const DATABASE_VERSION = 2;\n\nconst currentDbVersion = (\n  await db.getFirstAsync<{ user_version: number }>(\n    \"PRAGMA user_version\"\n  )\n)?.user_version ?? null;\n\nif (currentDbVersion < DATABASE_VERSION) {\n  await runMigrations(currentDbVersion);\n}\n\nawait db.execAsync(\n  `PRAGMA user_version = ${DATABASE_VERSION}`\n);",
            "highlights": [1, 5, 13],
            "tooltips": [
              { "line": 5, "content": "Read current DB version" },
              { "line": 13, "content": "Update version after migration" }
            ]
          }
        ]
      },
      {
        "id": "high-stability-download",
        "title": "High-Stability Download Engine - Large File Transfer",
        "role": "React Native Developer",
        "icon": "download-cloud",
        "summary": "Wrapped createDownloadResumable to achieve non-blocking transfer and real-time progress tracking.",
        "tags": ["File System", "Async Storage", "UX"],
        "challenge": {
          "title": "Challenge",
          "items": [
            "UI blocked during large file downloads; progress tracking was unavailable",
            "Native download API lacked progress callbacks and non-blocking transfer mechanisms",
            "Users were unable to know download status, leading to poor experience"
          ]
        },
        "analysis": {
          "title": "Analysis",
          "items": [
            "Researched expo-file-system download mechanisms",
            "Investigated implementation of non-blocking progress listener callbacks"
          ]
        },
        "decisions": {
          "title": "Engineering Decisions",
          "items": [
            {
              "title": "File Transfer Strategy",
              "items": [
                {
                  "title": "High-Stability Download Engine",
                  "desc": "Pros: Wraps createDownloadResumable for non-blocking transfer with real-time progress callback (onProgress) to update UI.",
                  "highlight": true
                },
                {
                  "title": "Simple fetch/downloadAsync",
                  "desc": "Cons: UI freezes during download; does not support resumable downloads."
                }
              ]
            }
          ]
        },
        "result": {
          "title": "Result",
          "items": [
            "Real-time progress tracking with non-blocking large file transfer",
            "Improved stability and user experience for large file operations"
          ]
        },
        "codeSnippetTabs": [
          {
            "label": "Download",
            "title": "Resumable Download Wrapper",
            "language": "typescript",
            "code": "const downloadResumable = FileSystem\n  .createDownloadResumable(\n    `${this.origin}/${remotePath}`,\n    localTempPath,\n    {},\n    (progress) => onProgress?.({\n      progress: progress.totalBytesWritten /\n        progress.totalBytesExpectedToWrite\n    })\n  );\n\nconst result = await downloadResumable\n  .downloadAsync();",
            "highlights": [2, 5],
            "tooltips": [
              { "line": 2, "content": "Create resumable download instance" },
              { "line": 5, "content": "Inject progress listener" }
            ]
          }
        ]
      }
    ],
    "gallery": {
      "tabs": {
        "demo": "Demo",
        "screenshots": "App Screenshots"
      },
      "demo": {
        "v1": {
          "title": "Music Filtering",
          "desc": "Demonstrates multi-condition filtering while keeping music playing"
        },
        "v2": {
          "title": "Music Detail Modal",
          "desc": "Tap song to show details including cover, artist, album"
        },
        "v3": {
          "title": "Batch Audio Download",
          "desc": "Demonstrates batch audio download with progress tracking"
        },
        "v4": {
          "title": "Music Upload",
          "desc": "Demonstrates music upload"
        }
      },
      "screenshots": {
        "s1": {
          "title": "Launch Screen - Light Theme",
          "desc": "App launch branding screen"
        },
        "s2": {
          "title": "Launch Screen - Dark Theme",
          "desc": "Launch screen with system dark mode support"
        },
        "s3": {
          "title": "Home Screen - Light Theme",
          "desc": "Music list with filter tags and playback controls"
        },
        "s4": {
          "title": "Home Screen - Dark Theme",
          "desc": "Dark mode music list interface"
        },
        "s5": {
          "title": "Profile Screen - Light Theme",
          "desc": "User settings and backup features"
        },
        "s6": {
          "title": "Profile Screen - Dark Theme",
          "desc": "Dark mode settings page"
        }
      }
    },
    "roadmap": {
      "title": "Future Roadmap & Optimization",
      "categories": [
        {
          "icon": "‚òÅÔ∏è",
          "title": "Cloud Ecosystem",
          "items": [
            "Google Drive Sync (Private Cloud Asset Management)",
            "Smart Prefetching (Background downloading for next track)",
            "Automated SQLite Backup"
          ]
        },
        {
          "icon": "‚ö°",
          "title": "Native Experience",
          "items": ["Robust Background Playback Service", "Advanced Playback Control (Loop modes, Sleep timer)"]
        },
        {
          "icon": "üè∑Ô∏è",
          "title": "Data Flexibility",
          "items": ["Dynamic Tagging System (Custom filters)", "Modify music Tagging"]
        }
      ]
    },
    "disclaimer": "This project is an open-source initiative for educational purposes. It focuses on technical implementation of offline-first architecture and private cloud synchronization. All media assets shown are for demonstration only."
  }
}
