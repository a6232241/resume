{
  "title": "AI Chat App",
  "shortDesc": "AI chat application integrated with GitHub Models and offline-first architecture.",
  "technologies": ["React Native", "Expo", "SQLite", "GitHub Models API"],
  "badge": "Native Integration",
  "role": "Personal Development / Technical Research",
  "detail": {
    "hero": {
      "title": "AI Chat App",
      "tagline": "AI-Powered √ó Offline-First √ó Native Integration",
      "summary": {
        "problem": {
          "title": "Challenge",
          "desc": "Standard Expo Go <highlight>lacks native module access</highlight> and network instability causes message handling issues"
        },
        "solution": {
          "title": "Solution",
          "desc": "Adopt Bare Workflow for deep native integration with Optimistic UI and Pre-network Persistence strategy"
        },
        "impact": {
          "title": "Impact",
          "desc": "Achieved <highlight>High-Reliability Error Recovery</highlight> and <highlight>Optimistic UI with Pre-network Persistence</highlight>"
        }
      }
    },
    "overview": {
      "description": "A high-performance AI chat application built on Expo Bare Workflow, leveraging GitHub Models for high-performance LLM integration and SQLite for secure data persistence.",
      "duration": "About 2 Months (Core Development)",
      "team": "Independent Research",
      "projectType": "Personal Project ¬∑ Mobile Full-Stack",
      "mainTechs": ["React Native", "Expo", "SQLite", "GitHub Models API"],
      "focus": ["Native Module Bridging", "SQLite Persistence", "Context Menu Integration"],
      "platforms": ["iOS", "Android"]
    },
    "technicalSpotlight": [
      {
        "id": "expo-bare-workflow",
        "title": "Expo Bare Workflow & Deep Native Integration",
        "role": "React Native Developer",
        "icon": "layers",
        "summary": "Migrated from Managed Workflow to Bare Workflow, retaining Expo DX while gaining specialized native project access.",
        "tags": ["Expo Bare Workflow", "Native Modules", "Architecture"],
        "challenge": {
          "title": "Challenge",
          "items": [
            "Standard Expo Go restricted custom native module extensibility",
            "Managed workflow abstracts native layer, blocking advanced haptics and system-level UI controls",
            "Unable to implement context menus and advanced gesture handling"
          ]
        },
        "analysis": {
          "title": "Analysis",
          "items": [
            "Evaluated differences between Expo Prebuild and Bare Workflow",
            "Confirmed react-native-context-menu-view required native linking"
          ]
        },
        "decisions": {
          "title": "Engineering Decisions",
          "items": [
            {
              "title": "Migration Strategy",
              "items": [
                {
                  "title": "Migrate to Bare Workflow",
                  "desc": "Pros: Retains Expo DX while gaining full native project access",
                  "highlight": true
                },
                {
                  "title": "Stay on Managed Workflow",
                  "desc": "Cons: Unable to integrate third-party libraries involving native UI View hierarchy"
                }
              ]
            }
          ]
        },
        "result": {
          "title": "Result",
          "items": [
            "Full control over Android/iOS projects with Expo's rapid iteration benefits",
            "Successfully integrated native Context Menu"
          ]
        },
        "codeSnippetTabs": [
          {
            "label": "Config",
            "title": "Expo Config Plugin Setup",
            "language": "json",
            "code": "{\n  \"expo\": {\n    \"ios\": {\n      \"bundleIdentifier\": \"com.a55663340.ai-chat-app\",\n      \"appleTeamId\": \"854H39T4U5\"\n    },\n    \"android\": {\n      \"package\": \"com.a55663340.aichatapp\"\n    },\n    \"plugins\": [\n      \"expo-router\",\n      [\"expo-sqlite\", { \"enableFTS\": true }]\n    ]\n  }\n}",
            "highlights": [4, 8, 10],
            "tooltips": [
              { "line": 4, "content": "Define iOS Bundle ID" },
              { "line": 8, "content": "Define Android Package Name" },
              { "line": 10, "content": "Configure Native Plugins" }
            ]
          }
        ]
      },
      {
        "id": "offline-persistence",
        "title": "Persistence Strategy: Balancing Responsiveness & Durability",
        "role": "React Native Developer",
        "icon": "database",
        "summary": "Combined Optimistic UI updates with Pre-network Persistence to ensure extreme perceived responsiveness and high data reliability.",
        "tags": ["Optimistic UI", "SQLite", "Offline First"],
        "challenge": {
          "title": "Challenge",
          "items": [
            "Trade-off between immediate user feedback and data persistence guarantees",
            "Pure optimistic UI risks data loss; pure DB-first creates perceived latency",
            "Needed instant feedback while ensuring messages are staged locally before the network request"
          ]
        },
        "analysis": {
          "title": "Analysis",
          "items": [
            "Analyzed impact of different persistence timing on UX and data safety",
            "Evaluated SQLite efficiency as a local cache"
          ]
        },
        "decisions": {
          "title": "Engineering Decisions",
          "items": [
            {
              "title": "Data Synchronization Strategy",
              "items": [
                {
                  "title": "Optimistic UI + Pre-network Persistence",
                  "desc": "Pros: Immediate UI updates provide zero-latency experience, and mandatory SQLite write before API execution ensures data safety",
                  "highlight": true
                },
                {
                  "title": "Pure Optimistic UI",
                  "desc": "Cons: If App crashes during API request, data is permanently lost"
                },
                {
                  "title": "Wait for API Response",
                  "desc": "Cons: Users perceive noticeable latency, poor experience"
                }
              ]
            }
          ]
        },
        "result": {
          "title": "Result",
          "items": [
            "Verified high-reliability data protection with extreme perceived responsiveness",
            "Ensured messages are locally staged even if crash occurs"
          ]
        },
        "codeSnippetTabs": [
          {
            "label": "Logic",
            "title": "Optimistic Update & Persistence Flow",
            "language": "typescript",
            "code": "// 1. Optimistic UI update: Provides immediate response experience\nsetMessages((prev) => [userMessage, ...prev]);\n\n// 2. Pre-network Persistence: Mandatory SQLite write before API call\nif (conversationId) {\n  await Apis.sqlite.message.putMessage({ ...userMessage, conversationId });\n}\n\n// 3. Initiate API call: Perform remote chat request\nconst response = await Apis.githubModel.postMessageToChat(...);",
            "highlights": [2, 6, 10],
            "tooltips": [
              { "line": 2, "content": "Immediately update UI state" },
              { "line": 6, "content": "Synchronously write to local database" },
              { "line": 10, "content": "Send network request" }
            ]
          }
        ]
      },
      {
        "id": "inverted-chat-list",
        "title": "Inverted List Implementation",
        "role": "React Native Developer",
        "icon": "list",
        "summary": "Utilized FlatList native inverted prop to achieve a natural chat interface and correct message ordering.",
        "tags": ["FlatList", "UI/UX", "Inverted List"],
        "challenge": {
          "title": "Challenge",
          "items": [
            "Chat messages displayed in wrong order (newest at top)",
            "Standard FlatList renders items top-to-bottom, opposite of chat UX expectations",
            "Users expected newest messages at bottom with auto-scroll"
          ]
        },
        "analysis": {
          "title": "Analysis",
          "items": [
            "Studied FlatList inverted prop mechanism",
            "Compared performance between manual array reversal and native prop usage"
          ]
        },
        "decisions": {
          "title": "Engineering Decisions",
          "items": [
            {
              "title": "List Rendering Strategy",
              "items": [
                {
                  "title": "FlatList inverted Prop",
                  "desc": "Pros: Native implementation, newest messages automatically at bottom, stable scroll position on data updates",
                  "highlight": true
                },
                {
                  "title": "Manual Array Reversal",
                  "desc": "Cons: Requires re-calculating array on every render"
                }
              ]
            }
          ]
        },
        "result": {
          "title": "Result",
          "items": [
            "Natural chat interface with correct message ordering",
            "Fluid scrolling experience when new messages arrive"
          ]
        },
        "codeSnippetTabs": [
          {
            "label": "Component",
            "title": "Inverted FlatList Implementation",
            "language": "tsx",
            "code": "<FlatList\n  ref={flatListRef}\n  inverted\n  data={messages}\n  keyExtractor={(item) =>\n    item.id.toString()\n  }\n  renderItem={renderMessageItem}\n/>",
            "highlights": [3],
            "tooltips": [{ "line": 3, "content": "Enable inverted rendering mode" }]
          }
        ]
      }
    ],
    "decisions": {
      "title": "Architectural Decisions",
      "subtitle": "Why & How",
      "items": [
        {
          "icon": "ü§ñ",
          "title": "Why GitHub Models?",
          "reason": "Cost-effective for research with free tier during development",
          "details": [
            "Seamless API integration with multiple LLM providers",
            "Architected for future scalability to support GPT-4, DeepSeek, and other LLMs via a unified API",
            "No credit card required for initial development phase"
          ]
        },
        {
          "icon": "üóÑÔ∏è",
          "title": "Why SQLite?",
          "reason": "Complex data relations required a relational database",
          "details": [
            "One-to-many relationship: Conversations ‚Üí Messages",
            "Efficient querying with proper indexing",
            "AsyncStorage inadequate for structured data with relationships"
          ]
        },
        {
          "icon": "üì±",
          "title": "Why Context Menu?",
          "reason": "Native iOS experience for message actions",
          "details": [
            "Long-press to reveal delete/resend options",
            "Integrated react-native-context-menu-view",
            "Haptic feedback on interaction"
          ]
        }
      ]
    },
    "gallery": {
      "tabs": {
        "demo": "Demo",
        "screenshots": "App Screenshots"
      },
      "demo": {
        "v1": {
          "title": "Send Message",
          "desc": "Demonstrates real-time message sending with AI response"
        },
        "v2": {
          "title": "Resend Failed Message",
          "desc": "Shows manual resend via context menu for failed messages"
        },
        "v3": {
          "title": "Delete Message",
          "desc": "Context menu integration for message deletion"
        },
        "v4": {
          "title": "Pre-network Persistence",
          "desc": "Demonstrates pre-network persistence with optimistic UI and local staging"
        }
      },
      "screenshots": {
        "s1": {
          "title": "Launch Screen - Dark",
          "desc": "App launch screen with dark theme"
        },
        "s2": {
          "title": "Launch Screen - Light",
          "desc": "App launch screen with light theme"
        },
        "s3": {
          "title": "Chat Screen - Dark",
          "desc": "Main chat interface in dark mode"
        },
        "s4": {
          "title": "Chat Screen - Light",
          "desc": "Main chat interface in light mode"
        }
      }
    },
    "coreImplementation": {
      "title": "Core Implementation",
      "subtitle": "Verified Features",
      "categories": [
        {
          "icon": "‚úÖ",
          "title": "Pre-network Persistence",
          "status": "verified",
          "items": [
            "Optimistic UI with local staging",
            "SQLite write before API call ensures durability",
            "Significantly enhanced data reliability"
          ]
        }
      ]
    },
    "roadmap": {
      "title": "Future Implementation",
      "subtitle": "Planned Enhancements",
      "categories": [
        {
          "icon": "üîÑ",
          "title": "State Machine",
          "items": ["Complete Sending/Sent status transitions", "Visual indicators for message states"]
        },
        {
          "icon": "‚ö°",
          "title": "Performance",
          "items": ["FlatList windowSize optimization", "getItemLayout for instant scrolling"]
        },
        {
          "icon": "üåê",
          "title": "Network",
          "items": [
            "Automatic Offline Sync (Background)",
            "Network status detection",
            "Automatic retry on reconnection"
          ]
        },
        {
          "icon": "ü§ñ",
          "title": "Model Evolution",
          "items": [
            "Implement multi-model switching UI (GPT-4 / DeepSeek / Claude)",
            "Support custom API endpoint integration"
          ]
        }
      ]
    },
    "disclaimer": "This project is an open-source educational demonstration. It focuses on native module integration and offline-first architecture patterns."
  }
}
