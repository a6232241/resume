{
  "shortDesc": "Led the development of a Web3 O2O ecosystem comprising 9 microservices. Delivered full-lifecycle features from DB schema design to mobile UI, integrating NFC verification and Shopify automation.",
  "technologies": ["React Native", "Swift App Clips", "Next.js", "Node.js", "Prisma", "Shopify API", "Web3"],
  "role": "Software Developer",
  "achievements": [],
  "fullDesc": "A comprehensive Web3 smart retail ecosystem. Merchants manage and analyze products via a backend dashboard, while consumers scan product tags to unlock verified information, special promotions, NFTs, and giveaways, integrated with third-party wallets.",
  "detail": {
    "hero": {
      "title": "Berify",
      "tagline": "Distributed O2O Ecosystem Â· 9 Independent Sub-projects",
      "description": "A Web3 smart retail ecosystem integrating NFC verification, NFT minting, and Shopify e-commerce. Verified pattern of full-stack feature ownership across the entire delivery lifecycle.",
      "statusBadge": "Currently in Production"
    },
    "overview": {
      "duration": "Tenure: 1 Year 5 Months (2023 - 2024)",
      "team": "8-Person Collaborative Team",
      "projectType": "Commercial Product",
      "mainTechs": ["React Native", "Swift App Clips", "Next.js", "Node.js", "Prisma", "Shopify API", "Web3"],
      "platforms": ["iOS", "Android", "Web"]
    },
    "architectureFlow": {
      "title": "System Architecture Chain",
      "steps": [
        { "step": "1", "title": "App (NFC Scan)", "desc": "React Native Client", "metric": "Trigger Interaction" },
        { "step": "2", "title": "App-Backend", "desc": "Web3 & API Gateway", "metric": "Business Logic" },
        {
          "step": "3",
          "title": "Berify-DB & Queue",
          "desc": "SMA State Machine & Task Queue",
          "metric": "Async Processing"
        },
        {
          "step": "4",
          "title": "WebSocket & SNS",
          "desc": "Instant Notifications & Cloud Push",
          "metric": "Dual-way Feedback"
        }
      ]
    },
    "ecosystemMetrics": {
      "title": "ðŸŒ System Architecture & Distributed Scale",
      "items": [
        { "value": "9", "label": "Independent Sub-projects", "desc": "3 Apps + 1 Tool Lib + 1 DB + 4 Microservices" },
        { "value": "114+", "label": "DB Migrations", "desc": "Architectural Evolution History" },
        { "value": "83", "label": "Core Data Models", "desc": "Foundation for Complex Business Logic" }
      ]
    },
    "metrics": {
      "title": "ðŸš€ Core Engineering Impact Metrics",
      "items": [
        { "value": "2,288+", "label": "Total Commits", "desc": "Proof of High-Intensity Continuous Delivery" },
        { "value": "97k+", "label": "Lines of Code", "desc": "Core System Implementation" },
        { "value": "60% / 34%", "label": "Mobile / Backend", "desc": "Full-Lifecycle Ownership: Schema â†’ API â†’ UI" }
      ]
    },
    "technicalSpotlight": [
      {
        "id": "idv",
        "title": "Staff Access Control (IDV)",
        "role": "Lead Logic Integrator",
        "icon": "shield",
        "summary": "Biometric Security & Inviter-Led Arbitration",
        "blocks": [
          {
            "type": "list",
            "title": "Goal",
            "items": [
              "Prevent unauthorized personnel from tampering with tag information or accessing highly sensitive assets via the mobile app."
            ]
          },
          {
            "type": "grid",
            "title": "Core Features",
            "items": [
              {
                "icon": "ðŸŽ­",
                "title": "Prevent Identity Fraud",
                "desc": "Prevent resigned or unauthorized employees from impersonating accounts to operate the system."
              },
              {
                "icon": "ðŸ“",
                "title": "Identity Consistency",
                "desc": "Ensure DB records are completely synchronized with government-issued legal ID documents."
              },
              {
                "icon": "ðŸ”’",
                "title": "Admin (Inviter) Arbitration",
                "desc": "Implement 'Admin Arbitration' mechanism; employees cannot modify key identity data themselves."
              }
            ]
          },
          {
            "type": "workflow",
            "title": "Architecture Design",
            "steps": [
              {
                "step": "1",
                "title": "Biometrics & Data Sync",
                "desc": "Integrate Incode SDK for face recognition, retrieve OCR data, and then execute backend verification logic."
              },
              {
                "step": "2",
                "title": "Multi-dim Consistency Check",
                "desc": "Implement backend '4-Way Matching' algorithm to automatically compare OCR raw data, App User info, and Web permission records."
              },
              {
                "step": "3",
                "title": "Async Conflict Arbitration",
                "desc": "When verification fails, the system sends an email notification to the inviter via SMTP/Email Service."
              },
              {
                "step": "4",
                "title": "Auto Data Repair",
                "desc": "Using a time-sensitive secure link, the inviter can approve and update the identity status with one click."
              }
            ]
          }
        ],
        "codeSnippet": {
          "title": "Face Login Orchestration",
          "language": "typescript",
          "code": "const startFaceLogin = async () => {\n  // 1. Initialize SDK Face Login\n  const result = await IncodeSdk.startFaceLogin({ showTutorials: false });\n  \n  // 2. Fetch OCR data via Backend API\n  const { ocrData } = await berifyAppApi.incode.getOcrData({\n    id: result.customerUUID,\n    token: result.token\n  });\n  \n  // 3. Call verify-idv API for 4-way matching\n  const response = await berifyAppApi.user.verifyIDV(userId, {\n    firstName: ocrData.name.firstName,\n    lastName: ocrData.name.paternalLastName,\n    email: session.user.email,\n    idvToken: result.token\n  });\n  \n  if (response.success) {\n    // 4. Verification success: Log time and grant access\n    await AsyncStorage.setItem('idvVerifyTime', JSON.stringify(new Date()));\n    setIsBerifyToolEnable(true);\n    navigation.navigate('Landing');\n  } else {\n    // 5. Name mismatch: System emails inviter; Frontend shows notice\n    Alert.alert('Notice', response.error);\n  }\n};"
        }
      },
      {
        "id": "collection & reward",
        "title": "Collection & Reward Engine",
        "role": "System Architect",
        "icon": "zap",
        "summary": "Gamification & E-commerce Integration",
        "blocks": [
          {
            "type": "architecture",
            "title": "Three-Layer Architecture Model",
            "layers": [
              {
                "name": "Rule (Brand)",
                "desc": "Defines campaign scope, batch associations, and Shopify reward variants",
                "role": "Configuration"
              },
              {
                "name": "Collection (Progress)",
                "desc": "Tracks user participation and automates Shopify Draft Order fulfillment",
                "role": "State Management"
              },
              {
                "name": "Item (Tag)",
                "desc": "Ensures global uniqueness of physical NFC tags via DB constraints",
                "role": "Unique Asset"
              }
            ]
          },
          {
            "type": "grid",
            "title": "Core Features",
            "items": [
              {
                "icon": "ðŸ›¡ï¸",
                "title": "Physical Integrity",
                "desc": "Implemented `@unique` on `CollectionItem` to prevent duplicate tag claims globally."
              },
              {
                "icon": "ðŸ”„",
                "title": "Cross-Batch Validation",
                "desc": "Check `item.tag.batch.id` relation to ensure users collect 'different' product batches."
              },
              {
                "icon": "ðŸ›ï¸",
                "title": "Shopify Automation",
                "desc": "Auto-creates `DraftOrder` with 100% discount links upon completion, closing the O2O loop."
              }
            ]
          }
        ],
        "codeSnippet": {
          "title": "Data Model & Relation-Based Validation",
          "language": "typescript",
          "code": "// 1. Physical Layer Integrity (Schema)\nmodel CollectionItem {\n  tagTokenId String @unique // Table-wide unique\n  tag        Tag    @relation(...) // Access Batch info via relation\n}\n\n// 2. Cross-Batch Validation (Business Logic)\n// Look up batch info via Tag relation for comparison\nconst batchIds = collection.items.map(item => item.tag.batch.id);\nif (batchIds.includes(currentBatchId)) {\n   // If batch already exists, reject or open new progress\n   openNewCollection();\n}"
        }
      },
      {
        "id": "social",
        "title": "Social Module",
        "role": "Architect of Dual-Pointer Schema",
        "icon": "database",
        "summary": "Interaction Systems",
        "blocks": [
          {
            "type": "workflow",
            "title": "Dual-Pointer Architecture",
            "steps": [
              { "step": "1", "title": "Structured Fetching", "desc": "rootReplyCommentId for fast thread mounting" },
              {
                "step": "2",
                "title": "Atomic Soft Delete",
                "desc": "isDeleted flag for traceability and data integrity"
              },
              {
                "step": "3",
                "title": "UI Linkage",
                "desc": "Filter root nodes in queries to hide deleted threads instantly"
              }
            ]
          },
          {
            "type": "grid",
            "title": "Architectural Analysis",
            "items": [
              {
                "icon": "âš¡",
                "title": "Query Performance",
                "desc": "Optimized from O(n) recursive calls to O(1) index scanning"
              },
              { "icon": "ðŸ“", "title": "Schema Design", "desc": "Dual-pointer optimization for flattened threads" },
              { "icon": "ðŸ›¡ï¸", "title": "Logical Consistency", "desc": "Real-time thread hiding via soft-delete status" }
            ]
          }
        ],
        "codeSnippet": {
          "title": "Dual-Pointer Schema & Efficient Query Logic",
          "language": "typescript",
          "code": "// 1. Optimizing Recursive Bottlenecks\nmodel Comment {\n  id                 Int     @id @default(autoincrement())\n  replyCommentId     Int?    // Direct Parent\n  rootReplyCommentId Int?    // Thread Root (Optimization Core)\n  isDeleted          Boolean @default(false)\n}\n\n// 2. Efficient Query Implementation\n// Avoid recursion; fetch entire thread in a single query\nconst thread = await db.comment.findMany({\n  where: { \n    rootReplyCommentId: rootId,\n    isDeleted: false \n  },\n  include: { /* Nested Relations */ }\n});"
        }
      },
      {
        "id": "nfc",
        "title": "NFC Orchestration",
        "role": "State Design & Optimization",
        "icon": "layout",
        "summary": "Physical-Digital Bridge",
        "blocks": [
          {
            "type": "workflow",
            "title": "NFC State Lifecycle",
            "steps": [
              { "step": "1", "title": "Hardware Trigger", "desc": "NfcManager captures NDEF events" },
              { "step": "2", "title": "Async Verification", "desc": "Parse Payload -> Call createScan API" },
              {
                "step": "3",
                "title": "State Decision",
                "desc": "Success triggers delayed navigation; Failures route to error screens"
              },
              { "step": "4", "title": "Side Effects", "desc": "Trigger Automated Notifications on success page mount" }
            ]
          },
          {
            "type": "challenges",
            "title": "Challenges & Solutions",
            "items": [
              {
                "title": "Async State Logic Injection",
                "symptom": "Hardware scanning involves both hardware interrupts and network requests, leading to UI inconsistency.",
                "solution": "Injected async state machine logic into the shared `useNormalTag` Hook, encapsulating NDEF parsing and Promise verification chains.",
                "result": "Transformed unpredictable hardware behavior into predictable business states, ensuring tag verification stability."
              },
              {
                "title": "Error Diagnosis & Routing",
                "symptom": "Complex error types (forgery, deactivation, timeouts) require distinct user guidance.",
                "solution": "Independently implemented `onRedirectScanResult` defensive routing, using a Switch-Case strategy to handle diverse API error codes.",
                "result": "Ensured 100% of exception scenarios have corresponding UI guidance, improving anti-counterfeit verification UX."
              }
            ]
          }
        ],
        "codeSnippet": {
          "title": "Routing & Error Handling Logic",
          "language": "typescript",
          "code": "const onRedirectScanResult = (error?: string) => {\n  switch (error) {\n    case 'Token is not exist.':\n    case 'tokenId and UID do not match.':\n      // Handle forged or incorrect tags\n      navigation.navigate(routes.scanResult.verifyError);\n      break;\n    case 'This tag is deactivated.':\n      // Handle deactivated tags\n      navigation.navigate(routes.scanResult.inactive);\n      break;\n    default:\n      if (!error) {\n        // Success path: Delay navigation for visual continuity\n        setTimeout(() => navigation.navigate(routes.scanResult.success), DELAY_MS);\n      } else {\n        navigation.navigate(routes.scanResult.timeOut);\n      }\n  }\n};"
        }
      },
      {
        "id": "infrastructure",
        "title": "Cross-Platform Build Architecture",
        "role": "Infrastructure Engineering",
        "icon": "settings",
        "summary": "Ensuring Xcode upgrade stability via automated patches, and resolving root causes through dependency version management.",
        "blocks": [
          {
            "type": "workflow",
            "title": "Cross-Platform Build Process",
            "steps": [
              { "step": "1", "title": "Environment Diagnosis", "desc": "Diagnosis and build error analysis" },
              { "step": "2", "title": "Patch Implementation", "desc": "Inject build flags to fix compatibility" },
              { "step": "3", "title": "Dependency Migration", "desc": "Migrate to official Scoped Package" },
              { "step": "4", "title": "Stability Verification", "desc": "Verify resolution of Binary SDK deadlocks" }
            ]
          },
          {
            "type": "challenges",
            "title": "Challenges & Solutions",
            "items": [
              {
                "title": "iOS Toolchain Adaptation",
                "symptom": "Swift Interface verification failures in Xcode 14.3+.",
                "action": "Injected `-no-verify-emitted-module-interface` flag via Podfile `post_install` and unified Deployment Target (12.4).",
                "result": "Resolved build deadlocks for team-wide Binary Framework compilation."
              },
              {
                "title": "Android SDK & Dependency Lifecycle",
                "symptom": "Camera module crashes with Incode SDK v2.6.3 on Android.",
                "solution": "Diagnosed Native Core errors, rolled back to stable 2.6.1, and led the migration from private S3 Tarballs to official @incode-sdks Scoped Packages.",
                "result": "Eliminated runtime crashes, ensuring stable IDV verification flow."
              }
            ]
          }
        ],
        "codeSnippet": {
          "title": "Podfile post_install Hack",
          "language": "ruby",
          "code": "installer.pods_project.targets.each do |target|\n  target.build_configurations.each do |config|\n    config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '12.4'\n    config.build_settings['OTHER_SWIFT_FLAGS'] ||= ['$(inherited)', '-no-verify-emitted-module-interface']\n  end\nend"
        }
      },
      {
        "id": "app-clip",
        "title": "App Clip Lightweight Architecture",
        "role": "Native iOS Lead",
        "icon": "smartphone",
        "summary": "Optimizing lifecycle management for lightweight NFC experiences, and implementing hardware protocol extensions.",
        "blocks": [
          {
            "type": "workflow",
            "title": "Lightweight Scan Workflow",
            "steps": [
              { "step": "1", "title": "State Diagnosis", "desc": "Detect current UI stack" },
              { "step": "2", "title": "View Cleanup", "desc": "Automatically dismiss residual windows" },
              { "step": "3", "title": "NDEF Parsing", "desc": "Parse Tail Tag protocol" },
              { "step": "4", "title": "Business Navigation", "desc": "Trigger App Clip exclusive API" }
            ]
          },
          {
            "type": "challenges",
            "title": "Challenges & Solutions",
            "items": [
              {
                "title": "Native Lifecycle & UI Reset",
                "badge": "Lifecycle Control",
                "icon": "ðŸ”„",
                "symptom": "Old result page not closing leads to UI conflict when scanning a new tag.",
                "solution": "Implement useLandingController recursive cleanup mechanism for view controllers.",
                "result": "Ensure every scan triggers from a clean initial state, improving navigation reliability by 100%."
              },
              {
                "title": "Hardware Protocol Extension & Compatibility",
                "badge": "Protocol Ext",
                "icon": "ðŸ·ï¸",
                "symptom": "Need to support non-standard \"Tail Tag\" hardware specs.",
                "solution": "Write NDEF raw packet parsing logic to dynamically identify specific URL parameters (e.g., ?data=00c).",
                "result": "Successfully extended hardware support, compatible with special spec tags."
              }
            ]
          }
        ],
        "codeSnippet": {
          "title": "Native UI Stack Cleanup Logic",
          "language": "swift",
          "code": "// Ensure atomicity of App Clip scan flow via recursive dismiss\nfunc useLandingController() -> LandingViewController? {\n  let keyWindow = UIApplication.shared.windows.filter {$0.isKeyWindow}.first\n  if var topController = keyWindow?.rootViewController {\n    // Auto-cleanup residual scan results or error pages\n    while let presentedViewController = topController.presentedViewController {\n      topController = presentedViewController\n    }\n    topController.dismiss(animated: false)\n  }\n  return keyWindow?.rootViewController as? LandingViewController\n}"
        }
      }
    ],
    "gallery": {
      "tabs": {
        "consumerApp": "Consumer Experience",
        "merchantDashboard": "Merchant Dashboard"
      },
      "consumerApp": {
        "home": { "title": "Home", "desc": "NFC Product Verification Portal" },
        "productDetail": { "title": "Product Detail", "desc": "Blockchain Verification & NFT Assets" },
        "chat": { "title": "Real-time Interaction", "desc": "WebSocket Brand Community Chat" },
        "rewards": { "title": "Rewards Center", "desc": "Shopify Discount Sync" },
        "rewardsDetail": { "title": "Reward Detail", "desc": "Redeem Points for Exclusive Discounts" },
        "notifications": { "title": "Notification Center", "desc": "AWS SNS Cloud Push" },
        "profile": { "title": "Profile", "desc": "Personal Profile" },
        "scanHistory": { "title": "Scan History", "desc": "Product Interaction Records" }
      },
      "merchantDashboard": {
        "dashboard": { "title": "Dashboard", "desc": "Multi-dimensional Analytics" },
        "inventory": { "title": "Inventory Management", "desc": "Digital Tag Management" },
        "experience": { "title": "Experience Management", "desc": "Cross-branch Digital Experiences" },
        "experienceDetail": { "title": "Experience Detail", "desc": "Raffle Rules & NFT Configuration" },
        "rewards": { "title": "Reward Strategies", "desc": "O2O Promotion Rules" },
        "account": { "title": "Access Management", "desc": "Granular Roles & Permissions" }
      },
      "thirdParty": {
        "shopify": "Integrated Shopify API for O2O Synchronization",
        "arbitrum": "Arbitrum Nova for Low-Latency NFT Distribution"
      }
    },
    "disclaimer": "This page showcases content from a commercial project. Screenshots are for portfolio demonstration purposes only."
  }
}
