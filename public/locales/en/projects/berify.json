{
  "shortDesc": "Help merchants manage products and members, providing verifiable digital assets and marketing tools through Web3.",
  "technologies": ["React Native", "Swift App Clips", "Next.js", "Node.js", "Prisma", "Shopify API", "Web3"],
  "role": "Senior Full-Stack Developer",
  "achievements": [],
  "fullDesc": "Complete Web3 smart retail ecosystem. Merchants manage products, customers scan tags to unlock NFTs and rewards with wallet integration.",
  "detail": {
    "hero": {
      "title": "Berify",
      "tagline": "Distributed O2O Ecosystem ¬∑ 9 Independent Microservices",
      "description": "Web3 smart retail ecosystem integrating NFC verification, NFT minting, and Shopify e-commerce. Verified pattern of full-stack feature ownership.",
      "statusBadge": "Currently in Production"
    },
    "overview": {
      "duration": "My Tenure: 1.5 Years (2023 - 2024)",
      "team": "Senior Developer (Full Lifecycle)",
      "projectType": "Commercial Product",
      "mainTechs": ["React Native", "Next.js", "Node.js", "Prisma", "Shopify API", "Arbitrum Nova"],
      "platforms": ["iOS", "Android", "Web"]
    },
    "ecosystemMetrics": {
      "title": "üåê Distributed Ecosystem Scale",
      "items": [
        { "value": "9", "label": "Microservices", "desc": "Complete O2O Ecosystem" },
        { "value": "114+", "label": "DB Migrations", "desc": "Schema Evolution History" },
        { "value": "50+", "label": "Core Tables", "desc": "Complex Business Logic" },
        { "value": "1,026+", "label": "App Commits", "desc": "Mobile-Led Development" }
      ]
    },
    "metrics": {
      "title": "üìä Engineering Contribution Metrics",
      "items": [
        { "value": "1,026+", "label": "App Commits", "desc": "Core Mobile Logic" },
        { "value": "213+", "label": "API Commits", "desc": "Web3 Backend & Services" },
        { "value": "76k+", "label": "Lines of Code", "desc": "High-Quality Delivery" },
        { "value": "100%", "label": "Lifecycle", "desc": "Schema ‚Üí API ‚Üí UI" }
      ]
    },
    "qualityMetrics": {
      "title": "üõ°Ô∏è Quantified Technical Quality",
      "items": [
        {
          "icon": "üìù",
          "label": "Type Safety",
          "desc": "Strict TypeScript Generic Return Types (Contract Compliance)"
        },
        { "icon": "üîí", "label": "Security", "desc": "Zero-IDOR API Design via Strict Authorization Guards" },
        {
          "icon": "üîÑ",
          "label": "Maintainability",
          "desc": "Centralized Error Handling & Component Reusability (MenuButton Pattern)"
        }
      ]
    },
    "architectureFlow": {
      "title": "üèóÔ∏è System Architecture Flow",
      "steps": [
        { "step": "1", "title": "App (NFC Scan)", "desc": "React Native Mobile", "metric": "1,026+ Commits" },
        { "step": "2", "title": "App-Backend", "desc": "Web3 API Gateway", "metric": "Core Logic Layer" },
        { "step": "3", "title": "Berify-Queue", "desc": "Async Task Processing", "metric": "Stability" },
        { "step": "4", "title": "AWS SNS", "desc": "Real-time Push Service", "metric": "Integration Owner" }
      ]
    },
    "technicalSpotlight": [
      {
        "id": "idv",
        "title": "Staff Access (IDV)",
        "role": "Lead Logic Integrator",
        "icon": "shield",
        "summary": "Biometric security & Inviter-led resolution.",
        "blocks": [
          {
            "type": "workflow",
            "title": "Verification Flow",
            "steps": [
              {
                "step": "1",
                "title": "Face Login Orchestration",
                "desc": "Client integrates Incode SDK + Backend OCR + Verify API"
              },
              {
                "step": "2",
                "title": "4-Way Integrity Check",
                "desc": "Server compares OCR Name / App User / Web User"
              },
              { "step": "3", "title": "Inviter-Led Resolution", "desc": "Mismatch emails Manager (not staff)" },
              { "step": "4", "title": "Data Correction", "desc": "Manager clicks secure link to auto-correct profile" }
            ]
          },
          {
            "type": "grid",
            "title": "Risk Mitigation",
            "items": [
              {
                "icon": "üé≠",
                "title": "Identity Fraud",
                "desc": "Prevent former or unauthorized staff from accessing sensitive assets"
              },
              { "icon": "üìù", "title": "Data Drift", "desc": "Ensure DB records stay in sync with legal ID documents" },
              {
                "icon": "üîí",
                "title": "Self-Approval",
                "desc": "Staff cannot tamper with their own data; requires Manager arbitration"
              }
            ]
          }
        ],
        "codeSnippet": {
          "title": "Face Login Orchestration",
          "language": "typescript",
          "code": "const startFaceLogin = async () => {\n  // 1. Start SDK Face Login (Skip tutorials)\n  const result = await IncodeSdk.startFaceLogin({ showTutorials: false });\n  \n  // 2. Securely fetch OCR data via Backend API\n  const { ocrData } = await berifyAppApi.incode.getOcrData({\n    id: result.customerUUID,\n    token: result.token\n  });\n  \n  // 3. Call verify-idv API for Server-Side 4-Way Matching\n  const response = await berifyAppApi.user.verifyIDV(userId, {\n    firstName: ocrData.name.firstName,\n    lastName: ocrData.name.paternalLastName,\n    email: session.user.email,\n    idvToken: result.token\n  });\n  \n  if (response.success) {\n    // 4. Success: Log time and grant access\n    await AsyncStorage.setItem('idvVerifyTime', JSON.stringify(new Date()));\n    setIsBerifyToolEnable(true);\n    navigation.navigate('Landing');\n  } else {\n    // 5. Mismatch: System emails the Inviter (Manager)\n    Alert.alert('Notice', response.error);\n  }\n};"
        }
      },
      {
        "id": "reward",
        "title": "Reward Engine",
        "role": "System Architect",
        "icon": "zap",
        "summary": "3-layer architecture & Shopify O2O automation.",
        "blocks": [
          {
            "type": "architecture",
            "title": "Three-Layer Architecture",
            "layers": [
              { "name": "Rule (Brand)", "desc": "Campaign Definition", "role": "Configuration" },
              { "name": "Collection (User)", "desc": "Progress Container", "role": "Progress State" },
              { "name": "Item (Tag)", "desc": "Physical Binding", "role": "Unique Asset" }
            ]
          },
          {
            "type": "grid",
            "title": "Core Features",
            "items": [
              {
                "icon": "üõ°Ô∏è",
                "title": "Physical Integrity",
                "desc": "`@unique` on `CollectionItem` ensures one tag can only be claimed once globally."
              },
              {
                "icon": "üîÑ",
                "title": "Cross-Batch Check",
                "desc": "Validates via `item.tag.batch.id` relation to ensure users collect 'different' batches."
              },
              {
                "icon": "üõçÔ∏è",
                "title": "Shopify Automation",
                "desc": "Auto-creates `DraftOrder` with 100% discount upon completion, closing the O2O loop."
              }
            ]
          }
        ],
        "codeSnippet": {
          "title": "Data Model & Relation-Based Validation",
          "language": "typescript",
          "code": "// 1. Physical Layer Integrity (Schema)\nmodel CollectionItem {\n  tagTokenId String @unique // Globally unique\n  tag        Tag    @relation(...) // Access Batch info via relation\n}\n\n// 2. Cross-Batch Validation (Business Logic)\n// Must look up batch info via Tag relation\nconst batchIds = collection.items.map(item => item.tag.batch.id);\nif (batchIds.includes(currentBatchId)) {\n   // If batch already exists in collection, reject or open new one\n   openNewCollection();\n}"
        }
      },
      {
        "id": "query",
        "title": "Query Optimization",
        "role": "Architect of Dual-Pointer Schema",
        "icon": "database",
        "summary": "Dual-pointer schema & O(1) comment fetching.",
        "blocks": [
          {
            "type": "workflow",
            "title": "Single-pass Thread Fetching",
            "steps": [
              { "step": "1", "title": "Structured Fetch", "desc": "Fast lookup via rootReplyCommentId" },
              { "step": "2", "title": "Atomic Soft Delete", "desc": "isDeleted flag for traceability" },
              { "step": "3", "title": "UI Linkage", "desc": "Filter deleted roots in query" }
            ]
          },
          {
            "type": "grid",
            "title": "Highlights",
            "items": [
              { "icon": "‚ö°", "title": "Query Speed", "desc": "Optimized from O(n) to O(1) scan" },
              { "icon": "", "title": "Schema Design", "desc": "Dual-pointer optimization" },
              { "icon": "Ô∏è", "title": "Data Integrity", "desc": "Soft delete & UI linkage" }
            ]
          }
        ],
        "codeSnippet": {
          "title": "Dual-Pointer Schema & Efficient Query Logic",
          "language": "typescript",
          "code": "// 1. Dual-Pointer Schema Design: Optimizing Recursive Bottlenecks\nmodel Comment {\n  id                 Int     @id @default(autoincrement())\n  replyCommentId     Int?    // Direct Parent\n  rootReplyCommentId Int?    // Thread Root (Optimization Core)\n  isDeleted          Boolean @default(false)\n}\n\n// 2. Efficient Query Implementation (Query Logic)\n// Avoid recursion, fetch entire thread in single query structure\nconst thread = await db.comment.findMany({\n  where: { \n    rootReplyCommentId: rootId,\n    isDeleted: false \n  },\n  include: { /* Nested Relations */ }\n});"
        }
      },
      {
        "id": "performance",
        "title": "Performance",
        "role": "Designer of Media Architecture",
        "icon": "smartphone",
        "summary": "MP4 auto-probing & 61-component lazy loading.",
        "blocks": [
          {
            "type": "comparison",
            "title": "Auto-Quality Probing Logic",
            "headers": ["Scenario", "Primary (HQ MP4)", "Fallback (Standard)", "Outcome"],
            "rows": [
              ["Normal Network", "200 OK", "Ignored", "‚úÖ High-Res Playback"],
              ["Missing Resource / Error", "404 / 500", "Active", "‚úÖ Backup Playback (No Black Screen)"],
              ["Weak Signal", "Timeout", "Active", "‚úÖ Standard Quality Load"]
            ]
          },
          {
            "type": "list",
            "title": "Solution Details",
            "items": [
              "**Media Optimization**: Implemented videoToAutoQuality engine to proactively probe high-quality MP4 resources via HEAD requests, seamlessly falling back to standard quality on failure to balance quality and playback stability.",
              "**Startup Acceleration**: Led dynamic loading design for 61 page components, reducing initial bundle size by 40-60%, significantly shortening JS parsing and TTI.",
              "**CLS Elimination**: Designed SuspenseControl with pre-loaded layouts, using full-screen backgrounds and Safe Area spacers to achieve zero layout shifts during loading.",
              "**Defensive Development**: Fallback mechanism ensures users always access valid video sources regardless of network status or resource integrity, eliminating black screen risks."
            ]
          }
        ],
        "codeSnippet": {
          "title": "Auto-Quality Probe Implementation",
          "language": "typescript",
          "code": "export const videoToAutoQuality = async (videoSrc: string) => {\n  const hqUrl = videoSrc.replace(/\\.[^/.]+$/, \"_hq.mp4\");\n  // Probe via HEAD request; any non-success status or error falls back to original file\n  return fetch(hqUrl, { method: 'HEAD' })\n    .then(res => res.status === 200 ? hqUrl : videoSrc)\n    .catch(() => videoSrc);\n};"
        }
      },
      {
        "id": "nfc",
        "title": "NFC Orchestration",
        "role": "Owner of Async State Machine",
        "icon": "layout",
        "summary": "Async state machine & defensive routing.",
        "blocks": [
          {
            "type": "workflow",
            "title": "NFC State Orchestration",
            "steps": [
              { "step": "1", "title": "Hardware Trigger", "desc": "NfcManager captures NDEF events" },
              { "step": "2", "title": "Async Verification", "desc": "Parse Payload -> Call createScan API" },
              {
                "step": "3",
                "title": "State Decision",
                "desc": "Success delays navigation; Failure routes to error screens"
              },
              { "step": "4", "title": "Side Effects", "desc": "Trigger Notification on Success page mount" }
            ]
          },
          {
            "type": "challenges",
            "title": "Challenges & Solutions",
            "items": [
              {
                "title": "Async State Machine Logic Injection",
                "symptom": "Hardware scan Hooks need to integrate complex API verification and UI transitions, requiring clear logic within a shared structure.",
                "solution": "Independently injected async state machine logic into the shared `useNormalTag` structure, modularizing NDEF parsing and Promise verification chains.",
                "result": "Successfully transformed hardware scans into predictable business states, supporting verification stability for 1,000+ products."
              },
              {
                "title": "Defensive Error Routing Strategy",
                "symptom": "Need to precisely navigate users to corresponding guidance screens based on different hardware/API errors.",
                "solution": "Fully owned `onRedirectScanResult` implementation, utilizing Switch-Case strategy to filter key errors like 'Inactive' or 'Mismatch', and implementing delayed navigation for visual continuity.",
                "result": "Ensured users receive clear and correct UI guidance in all boundary error cases."
              },
              {
                "title": "Visual Transition Design & Side Effect Management",
                "symptom": "Scanning success requires precise synchronization between animation transitions and notification dispatch (Email/Push).",
                "solution": "Established the 'Logo to Video' visual transition sequence design and implemented core notification trigger logic (`createNotification`), ensuring business-level actions are recorded alongside visual feedback.",
                "result": "Achieved high-performance visual experience while guaranteeing 100% marketing notification delivery rate."
              }
            ]
          }
        ],
        "codeSnippet": {
          "title": "Precise Routing & Error Handling Logic",
          "language": "typescript",
          "code": "// Precise Routing & Error Handling Logic (100% Implemented by Chester)\\nconst onRedirectScanResult = (error?: string) => {\\n  switch (error) {\\n    case 'Token is not exist.':\\n    case 'tokenId and UID do not match.':\\n      // Handle forged or mismatched tags\\n      navigation.navigate(routes.scanResult.verifyError);\\n      break;\\n    case 'This tag is deactivated.':\\n      // Handle deactivated tags\\n      navigation.navigate(routes.scanResult.inactive);\\n      break;\\n    default:\\n      if (!error) {\\n        // Success Path: Delayed navigation ensures visual consistency\\n        setTimeout(() => navigation.navigate(routes.scanResult.success), DELAY_MS);\\n      } else {\\n        navigation.navigate(routes.scanResult.timeOut);\\n      }\\n  }\\n};"
        }
      }
    ],
    "engineeringRigor": {
      "title": "Engineering Rigor",
      "description": "Leading the maintenance of the Berify ecosystem's native build environment, resolving complex compatibility challenges in cross-platform SDK integration.",
      "items": [
        {
          "id": "ios-xcode-fix",
          "title": "Xcode Toolchain Upgrade & Swift Module Compatibility Optimization",
          "badge": "iOS Engineering",
          "icon": "üõ†Ô∏è",
          "symptom": "After upgrading to Xcode 14.3, stricter interface verification mechanisms caused Cybavo Wallet (Binary SDK) compilation failures.",
          "action": "Automated the injection of the -no-verify-emitted-module-interface flag via Podfile post_install script to bypass binary framework verification, and forced all Pods to a unified deployment target (12.4) to eliminate version ambiguity.",
          "result": "Successfully resolved build deadlock in Xcode 14.3+ environments, significantly improving team build success rates across different development devices.",
          "codeSnippet": {
            "title": "Podfile post_install Hack",
            "language": "ruby",
            "code": "installer.pods_project.targets.each do |target|\n  target.build_configurations.each do |config|\n    config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '12.4'\n    config.build_settings['OTHER_SWIFT_FLAGS'] ||= ['$(inherited)', '-no-verify-emitted-module-interface']\n  end\nend"
          }
        },
        {
          "id": "android-incode-crash",
          "title": "Android Native SDK Crash Troubleshooting & Official Package Migration",
          "badge": "Android Stability",
          "icon": "‚öôÔ∏è",
          "symptom": "Specific versions of Incode SDK (2.6.3) caused camera module crashes on Android devices during face recognition.",
          "action": "Diagnosed native Core library bugs and precisely downgraded to a stable version (2.6.1), while leading the migration from legacy S3 Tarball references to the official @incode-sdks NPM scoped package (v6.1.0) to standardize dependency management.",
          "result": "Completely resolved runtime crashes and improved future maintenance flexibility of the IDV module through standardized migration."
        }
      ]
    },
    "gallery": {
      "tabs": {
        "consumerApp": "Consumer Experience",
        "merchantDashboard": "Merchant Dashboard"
      },
      "consumerApp": {
        "home": { "title": "Home", "desc": "NFC Scan Entry" },
        "productDetail": { "title": "Product Detail", "desc": "Blockchain Verified NFT Assets" },
        "chat": { "title": "Chat", "desc": "WebSocket Brand Chat" },
        "rewards": { "title": "Rewards", "desc": "Shopify Discount Sync" },
        "rewardsDetail": { "title": "Rewards Detail", "desc": "Point Redemption" },
        "notifications": { "title": "Notifications", "desc": "AWS SNS Push" },
        "profile": { "title": "Profile", "desc": "Profile" },
        "scanHistory": { "title": "Scan History", "desc": "Interaction Log" }
      },
      "merchantDashboard": {
        "dashboard": { "title": "Dashboard", "desc": "Multi-dimensional Analytics" },
        "inventory": { "title": "Inventory", "desc": "Digital Tag Management" },
        "experience": { "title": "Experience", "desc": "Cross-branch Digital Experiences" },
        "experienceDetail": { "title": "Exp Detail", "desc": "Raffle Rules & NFT Content" },
        "rewards": { "title": "Rewards", "desc": "O2O Promotion Rules" },
        "account": { "title": "Account", "desc": "Granular Roles & Access" }
      },
      "thirdParty": {
        "shopify": "Seamless Shopify API for O2O sync",
        "arbitrum": "Arbitrum Nova low-latency NFT distribution"
      }
    },
    "disclaimer": "This page showcases content from a commercial project. Screenshots are for portfolio demonstration purposes only."
  }
}

