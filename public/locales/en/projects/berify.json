{
  "shortDesc": "Led the development of a Web3 O2O ecosystem comprising 9 microservices. Delivered full-lifecycle features from DB schema design to mobile UI, integrating NFC verification and Shopify automation.",
  "technologies": ["React Native", "Swift App Clips", "Next.js", "Node.js", "Prisma", "Shopify API", "Web3"],
  "role": "Software Developer",
  "achievements": [],
  "fullDesc": "A comprehensive Web3 smart retail ecosystem. Merchants manage and analyze products via a backend dashboard, while consumers scan product tags to unlock verified information, special promotions, NFTs, and giveaways, integrated with third-party wallets.",
  "detail": {
    "hero": {
      "title": "Berify",
      "tagline": "Distributed O2O Ecosystem Â· Microservices Architecture",
      "statusBadge": "Currently in Production"
    },
    "overview": {
      "description": "Combining <b>automated builds</b> and <b>non-recursive architecture</b> to resolve cross-platform compilation and performance bottlenecks. Bridging the O2O loop from <b>biometrics</b> to <b>Shopify</b>, providing <b>precise market insights</b> for merchants.",
      "duration": "Tenure: 1 Year 5 Months (2023 - 2024)",
      "team": "8-Person Collaborative Team",
      "projectType": "Commercial Product",
      "mainTechs": ["React Native", "Swift App Clips", "Next.js", "Node.js", "Prisma", "Shopify API", "Web3"],
      "platforms": ["iOS", "Android", "Web"]
    },
    "architectureFlow": {
      "title": "System Architecture Flow",
      "steps": [
        {
          "step": "1",
          "title": "App (NFC Scan)",
          "desc": "React Native & Swift App Clip",
          "metric": "Trigger Interaction"
        },
        { "step": "2", "title": "App-Backend", "desc": "Web3 & API Gateway", "metric": "Business Logic" },
        {
          "step": "3",
          "title": "Berify-DB & Queue",
          "desc": "Scheduler & Task Queue",
          "metric": "Async Processing"
        },
        {
          "step": "4",
          "title": "WebSocket & SNS",
          "desc": "Instant Notifications & Cloud Push",
          "metric": "Dual-way Feedback"
        }
      ]
    },
    "architectureMetrics": {
      "title": "Core Engineering & Contributions",
      "list": [
        {
          "title": "Immersive Interaction Experience",
          "metric": "Native-grade Fluidity",
          "desc": [
            "Encapsulated CustomFlatList to achieve parallax scrolling and sticky headers, providing a native-level smooth experience",
            "Implemented list viewport detection to precisely control asset loading timing within the visible area"
          ]
        },
        {
          "title": "High-Resilience Social Architecture",
          "metric": "Zero-Latency Feedback",
          "desc": [
            "Introduced optimistic updates to eliminate API wait times, significantly enhancing perceived performance",
            "Built offline retry queues to ensure eventual data consistency under unstable network conditions"
          ]
        },
        {
          "title": "Native Stability",
          "metric": "Cross-Platform Standardization",
          "desc": [
            "Resolved core module compilation conflicts, stabilizing native build environment",
            "Resolved App Clip view residue anomalies"
          ]
        }
      ]
    },
    "technicalSpotlight": [
      {
        "id": "app-clip",
        "title": "App Clip Navigation Fix: Resolving View Retention & State Management",
        "role": "Native iOS Lead",
        "icon": "smartphone",
        "summary": "Resolved navigation deadlock in scanning flows, enhancing user experience.",
        "tags": ["iOS Native", "State Reset", "NFC Optimization"],
        "challenge": {
          "title": "Challenge",
          "items": [
            "Subsequent NFC triggers in App Clip continued to show the previous scan's result page.",
            "This interrupted the user flow in physical scenarios, directly impacting scan conversion rates."
          ]
        },
        "analysis": {
          "title": "Analysis & Tools",
          "items": [
            "Investigated SceneDelegate and Root View Controller logic.",
            "Traced the presented state chain of UIViewControllers, confirming the system failed to auto-reset Modal Presentations."
          ]
        },
        "decisions": {
          "title": "Engineering Decisions",
          "items": [
            {
              "title": "Evaluation: How to Reset Navigation State?",
              "items": [
                {
                  "title": "Update Modal Content",
                  "desc": "Cons: Requires handling multiple states like loading, animation playing, failure, success."
                },
                {
                  "title": "Recursive Lookup & Force Dismiss",
                  "desc": "Pros: Effectively resets view state, ensuring lifecycle consistency.",
                  "highlight": true
                }
              ]
            }
          ]
        },
        "result": {
          "title": "Result",
          "items": [
            "Eliminated navigation blocking caused by UI conflicts.",
            "Improved fluidity from scanning to viewing product pages."
          ]
        },
        "codeSnippetTabs": [
          {
            "label": "Main Logic",
            "title": "Native UI Stack Cleanup Logic",
            "language": "swift",
            "code": "// Ensure atomicity of App Clip scan flow via recursive dismiss\nfunc useLandingController() -> LandingViewController? {\n  let keyWindow = UIApplication.shared.windows.filter {$0.isKeyWindow}.first\n  if var topController = keyWindow?.rootViewController {\n    // Find the topmost View Controller\n    while let presentedViewController = topController.presentedViewController {\n      topController = presentedViewController\n    }\n    // Safe cleanup: Dismiss only scan-related pages\n    if topController is ScanResultViewController || topController is ScanErrorViewController {\n        topController.dismiss(animated: false)\n    }\n  }\n  return keyWindow?.rootViewController as? LandingViewController\n}",
            "highlights": [6, 10, 11],
            "tooltips": [
              { "line": 6, "content": "Recursively find topmost Presented VC" },
              { "line": 10, "content": "Clean up only specific view types" },
              { "line": 11, "content": "Force remove residual windows (animated: false)" }
            ]
          }
        ]
      },
      {
        "id": "optimize-and-refactor-rewards",
        "title": "Rewards Refactor: Cross-Module Parallax & State Sync",
        "role": "Module Architecture Lead",
        "icon": "smartphone",
        "summary": "Established standardized animation state flow via Module-Scoped Context and CustomFlatList encapsulation, resolving complex nested scroll conflicts and ensuring precise cross-page UI & data sync.",
        "tags": ["React Context", "Custom Hook Encapsulation"],
        "challenge": {
          "title": "Challenge",
          "items": [
            "Cross-page data desynchronization caused frequent points display errors and customer complaints.",
            "Standard components could not support complex parallax blocks, resulting in severe scrolling stutter."
          ]
        },
        "decisions": {
          "title": "Engineering Decisions",
          "items": [
            {
              "title": "Decision 1: State Management Strategy - Multi-source Sync",
              "items": [
                {
                  "title": "Module-Level Context State with Auto-Broadcast",
                  "desc": "Pros: Context resolves local state sharing without adding bundle size; aligns with current architecture.",
                  "highlight": true
                },
                {
                  "title": "Redux or React Query for Server State",
                  "desc": "Cons: Current architecture lacks Redux; introducing it adds unnecessary complexity."
                }
              ]
            },
            {
              "title": "Decision 2: Parallax Scroll Strategy - Complex Scroll Issues",
              "items": [
                {
                  "title": "CustomFlatList (Custom Encapsulation)",
                  "desc": "Pros: Combines Content Padding & Native Driver to achieve smooth parallax scrolling.",
                  "highlight": true
                },
                {
                  "title": "ScrollView",
                  "desc": "Cons: Full rendering blocks main thread, unable to support long list performance."
                },
                {
                  "title": "FlatList",
                  "desc": "Cons: Standard Header coupled with scroll flow; cannot achieve parallax scaling and layer separation."
                },
                {
                  "title": "Reanimated + FlatList",
                  "desc": "Cons: Not aligned with current project architecture."
                }
              ]
            }
          ]
        },
        "showcase": {
          "alt": "Showcasing CustomFlatList Parallax Effect"
        },
        "result": {
          "title": "Result",
          "items": [
            "Unified cross-page state management, resolving customer complaints caused by points display errors.",
            "Overcame native component limitations, perfectly reproducing high-complexity parallax experience required by designers."
          ]
        },
        "codeSnippetTabs": [
          {
            "label": "Logic & Context",
            "title": "Native Driven Parallax: Context State Flow & Interpolation",
            "language": "typescript",
            "code": "// 1. Define Native Animation Interpolation in Context\nconst styles = useMemo(() => ({\n  background: {\n    transform: [\n      {\n        translateY: scrollY.interpolate({\n          inputRange: [0, headerHeight],\n          outputRange: [0, -headerHeight]\n        })\n      },\n      {\n        scale: scrollY.interpolate({\n          inputRange: [-windowHeight, 0],\n          outputRange: [4.2, 1]\n        })\n      }\n    ]\n  }\n}), [scrollY, headerHeight]);\n\nconst onScroll = Animated.event(\n  [{ nativeEvent: { contentOffset: { y: scrollY } } }],\n  { useNativeDriver: true }\n);",
            "highlights": [6, 7, 8, 12, 13, 14, 23],
            "tooltips": [
              { "line": 6, "content": "Calc Parallax Offset: Move background up on scroll for depth" },
              { "line": 12, "content": "Calc Scale: Zoom background on pull-down, simulating iOS elasticity" },
              { "line": 23, "content": "Enable useNativeDriver: Offload calc to UI thread for stable FPS" }
            ]
          },
          {
            "label": "Component View",
            "title": "Native Driven Parallax: Context State Flow & Interpolation",
            "language": "typescript",
            "code": "// 2. Consume Context in UI Layer & Bind Animation\nfunction CustomFlatList({ children, BackgroundComponent }) {\n  const { styles, onScroll } = useCustomFlatListContext();\n  return (\n    <Stack>\n      <Animated.View style={[styles.background]} pointerEvents='box-none'>\n        {BackgroundComponent}\n      </Animated.View>\n      <Animated.FlatList\n        onScroll={onScroll}\n        scrollEventThrottle={16}\n        {...props}\n      />\n    </Stack>\n  );\n}",
            "highlights": [10],
            "tooltips": [
              { "line": 10, "content": "Bind Animated.event: Link ScrollView offset directly to Animated.Value" }
            ]
          }
        ]
      },
      {
        "id": "native-stability-engineering",
        "title": "Native Build Stability Engineering: Eliminating iOS Build Blockers & Android Runtime Crashes",
        "role": "Mobile Infrastructure Lead",
        "icon": "smartphone",
        "summary": "Established native build environment standardization and resolved Xcode toolchain conflicts via compiler flag injection, ensuring build stability.",
        "tags": ["Native Infrastructure", "Build Automation", "Cross-Platform Stability"],
        "challenge": {
          "title": "Challenge",
          "items": [
            "Xcode upgrade triggered Binary SDK interface hash conflicts, blocking the build process.",
            "Specific version of native module caused camera crashes, interrupting the core IDV identity verification flow."
          ]
        },
        "analysis": {
          "title": "Analysis",
          "items": [
            "Analyzed Build Logs to diagnose interface hash conflicts between Binary SDK and new Swift compiler.",
            "Captured runtime error logs via Logcat, pinpointing internal camera module anomalies within the SDK."
          ]
        },
        "decisions": {
          "title": "Engineering Decisions",
          "items": [
            {
              "title": "iOS: Downgrade Dev Environment vs. Inject Compiler Flags",
              "items": [
                {
                  "title": "Inject compiler flags via Podfile to bypass hash verification",
                  "desc": "Pros: Instantly restores build flow with low intrusion while waiting for vendor fix.",
                  "highlight": true
                },
                {
                  "title": "Downgrade Development Environment",
                  "desc": "Cons: Sacrifices performance benefits and new features of newer Xcode, delaying technical debt repayment."
                },
                {
                  "title": "Wait for Vendor SDK Release",
                  "desc": "Cons: Uncontrollable vendor update schedule."
                }
              ]
            },
            {
              "title": "Android: Loose Versioning vs. Strict Dependency Locking",
              "items": [
                {
                  "title": "Migrate to official Scoped Package and implement strict version locking",
                  "desc": "Pros: Ensures build environment idempotency, fundamentally eliminating runtime crashes caused by dependency shifts.",
                  "highlight": true
                },
                {
                  "title": "Use Range Versioning (e.g., 2.6.+) for Automatic Updates",
                  "desc": "Cons: Introduces non-deterministic risks, unable to guarantee build consistency, potentially leading to recurrent crashes."
                }
              ]
            }
          ]
        },
        "result": {
          "title": "Result",
          "items": [
            "Established cross-platform compatibility standards, reducing repetitive debugging time caused by environmental discrepancies.",
            "Completely eradicated native layer camera crashes, restoring stable operation of IDV identity verification."
          ]
        },
        "codeSnippetTabs": [
          {
            "label": "iOS Build Automation",
            "title": "Build Automation: Compiler Flag Injection & Environment Standardization",
            "language": "ruby",
            "code": "installer.pods_project.targets.each do |target|\n  target.build_configurations.each do |config|\n    config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] =\n     '12.4'\n    config.build_settings['OTHER_SWIFT_FLAGS'] ||=\n     [\n      '$(inherited)',\n      '-no-verify-emitted-module-interface'\n     ]\n  end\nend",
            "highlights": [3, 4, 5, 6, 7, 8, 9],
            "tooltips": [
              {
                "line": 3,
                "content": "Standardize target version for all 3rd-party pods to eliminate compatibility warnings after Xcode upgrade"
              },
              {
                "line": 5,
                "content": "Tell compiler to skip hash verification for Binary SDK, resolving conflicts between old SDK and new Swift"
              }
            ]
          },
          {
            "label": "Android Dependency",
            "title": "Dependency Governance: Strict Locking & Idempotency",
            "language": "groovy",
            "code": "dependencies {\n  // implementation 'com.incode.sdk:core-light:2.6.+'\n  implementation 'com.incode.sdk:core-light:2.6.1'\n}",
            "highlights": [2, 3],
            "tooltips": [
              {
                "line": 2,
                "content": "Avoid using range versions"
              },
              {
                "line": 3,
                "content": "Force lock to specific Patch version to ensure build environment idempotency"
              }
            ]
          }
        ]
      }
    ],
    "gallery": {
      "tabs": {
        "consumerApp": "Consumer App"
      },
      "consumerApp": {
        "home": {
          "title": "Home",
          "desc": "Core Routing: Unified dispatch of NFC events and application initialization flow."
        },
        "productDetail": {
          "title": "Product Detail",
          "desc": "Banner View: Optimized horizontal scrolling via native ScrollView, ensuring seamless switching and rendering between product info and NFT credentials."
        },
        "chat": {
          "title": "Message Board",
          "desc": "Optimistic Updates: Implemented frontend caching and failure persistence to achieve zero-latency posting experience with offline retry support."
        },
        "rewardsDetail": {
          "title": "Reward Detail",
          "desc": "Advanced Scroll Interaction: Encapsulated CustomFlatList to deliver native-grade experiences like Parallax scrolling and Sticky Headers."
        },
        "scanHistory": {
          "title": "Scan History",
          "desc": "Virtualized List Rendering: Implemented viewport detection to intelligently load video/image assets only within the visible area, significantly reducing memory usage."
        }
      }
    },
    "disclaimer": "This page showcases content from a commercial project. Screenshots are for portfolio demonstration purposes only."
  }
}
