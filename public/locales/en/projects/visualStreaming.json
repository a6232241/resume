{
  "title": "Cross-platform real-time computer vision R&D project",
  "shortDesc": "Using React Native and C++ to integrate image processing libraries, achieving real-time image filtering and feature detection.",
  "technologies": ["React Native", "Kotlin/ObjC", "C++", "OpenCV", "JSI"],
  "achievements": [
    "80%+ C++ code reuse rate, sharing core logic across platforms",
    "Developed Native Components using RN's new architecture (Fabric & TurboModules)"
  ],
  "role": "Solo ¬∑ 4 Months",
  "badge": "High-Performance Arch",
  "detail": {
    "hero": {
      "title": "Cross-platform real-time computer vision R&D project",
      "tagline": "Real-time Live Streaming Face Swap PoC",
      "summary": {
        "problem": {
          "title": "Challenge",
          "desc": "Performance and cross-platform reuse challenges for mobile <highlight>real-time face processing</highlight>"
        },
        "solution": {
          "title": "Solution",
          "desc": "Non-blocking processing with JSI Worklets + 80% C++ shared core"
        },
        "impact": {
          "title": "Impact",
          "desc": "Achieved <highlight>real-time processing</highlight> and <highlight>dual-platform code reuse</highlight>"
        }
      }
    },
    "overview": {
      "description": "Achieving cross-platform high-performance real-time image processing through JSI and Shared C++ Core.",
      "duration": "4 Months",
      "team": "Solo Developer",
      "projectType": "Exploratory PoC Project",
      "focus": ["JSI Cross-layer Communication", "Coordinate System Mapping", "C++ Cross-platform Reuse"],
      "mainTechs": ["React Native", "Kotlin/ObjC", "C++", "OpenCV", "JSI"],
      "platforms": ["Android", "iOS"]
    },
    "challenges": [
      {
        "id": 1,
        "title": "Non-blocking UI - Main Thread Offloading",
        "symptom": "Face detection causes UI lag",
        "rootCause": "ML Kit face detection is a time-consuming operation; executing it on the main thread blocks rendering",
        "impact": "Laggy user experience, non-fluid interaction",
        "badge": "JSI Optimized",
        "metrics": {
          "label": "UI Response",
          "before": "Laggy",
          "after": "Instant"
        },
        "filePaths": ["App.tsx", "android/.../FrameEffectsOverlayView.kt", "ios/FaceDetector/FaceDetector.m"],
        "codeSnippets": [
          "// 1. JS Worklet Offloading\nrunAsync(frame, () => {\n  'worklet';\n  applyEffect(frame, cameraPosition);\n});",
          "// 2. Android Coroutines IO\ncoroutineScope.launch(Dispatchers.IO) {\n  targetFaces = FaceDetector.detect(image)\n}",
          "// 3. iOS GCD Offloading\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n  [self performDetectionOnImage:image completion:completion];\n});"
        ],
        "multiHighlightTerms": [
          ["runAsync", "'worklet'"],
          ["Dispatchers.IO", "coroutineScope.launch"],
          ["dispatch_async", "dispatch_get_global_queue"]
        ],
        "codeSnippetTableLabels": ["JS Layer", "Android Layer", "iOS Layer"],
        "solution": {
          "approach": "JSI Worklets + Native Async Offloading",
          "details": [
            "JS Layer: Implemented non-blocking frame processing pipeline via Vision Camera's runAsync",
            "Android Layer: Offloaded compute-intensive tasks using Kotlin Coroutines (Dispatchers.IO)",
            "iOS Layer: Used GCD (dispatch_async) to ensure main thread rendering is never interrupted"
          ],
          "result": "Ensures a fluid interaction experience at 60fps even under heavy AI computation loads"
        }
      },
      {
        "id": 2,
        "title": "Matrix Transformation - Coordinate Mapping",
        "symptom": "Face landmarks do not align with the preview",
        "rootCause": "Inconsistency between the coordinate systems of the Vision Camera preview and raw frame data",
        "impact": "Face swap effects appear in the wrong positions",
        "badge": "Precise Alignment",
        "metrics": {
          "label": "Coordinate Accuracy",
          "before": "Misaligned",
          "after": "Aligned"
        },
        "filePaths": ["App.tsx", "ImageUtils.kt", "FrameEffectsProcessorPlugin.m"],
        "codeSnippets": [
          "<Camera\n  // Disable native preview, use custom component for rendering\n  preview={false}\n/>\n<FrameEffectsOverlayViewNativeComponent\n  style={{flex: 1}}\n  effect={currentEffect}\n/>",
          "val matrix = Matrix()\nmatrix.postRotate(rotationDegrees.toFloat())\n\n// Handle mirroring compensation\nif (isHorizontalFlip) {\n  matrix.postScale(if (isHorizontalFlip) -1f else 1f, 1f, viewWidth / 2f, viewHeight / 2f)\n}",
          "UIImageOrientation orientation = frame.orientation;\nUIImage *image = [UIImage imageWithCGImage:cgImage\n                                     scale:1.0\n                               orientation:orientation];"
        ],
        "multiHighlightTerms": [
          ["preview={false}", "FrameEffectsOverlayViewNativeComponent"],
          ["Matrix", "postRotate", "postScale", "isHorizontalFlip"],
          ["UIImageOrientation", "frame.orientation", "orientation"]
        ],
        "codeSnippetTableLabels": ["JS Layer", "Android Layer", "iOS Layer"],
        "solution": {
          "approach": "Matrix.postRotate() (Android) / UIImageOrientation (iOS)",
          "details": [
            "JS Layer: Developed a custom native component to replace the default Vision Camera preview.",
            "Android: Manually applied rotation and mirroring compensation via Matrix before drawing to Canvas.",
            "iOS: Leveraged UIImageOrientation from the Vision Camera frame to automatically handle coordinate mapping during UIImage creation."
          ],
          "result": "Face landmarks align perfectly with the preview across multiple device orientations",
          "category": "Coordinate Mapping"
        }
      },
      {
        "id": 3,
        "title": "Shared C++ Core - 80% Code Reuse",
        "symptom": "Code duplication and complex maintenance",
        "rootCause": "Separate Android and iOS implementations leading to double the workload",
        "impact": "Prolonged project development cycle",
        "badge": "80%+ Reuse",
        "metrics": {
          "label": "Code Reuse Rate",
          "before": "0%",
          "after": "80%+"
        },
        "filePaths": ["face_processing_core.cpp", "face_processing_bridge_android.cpp", "FaceProcessingBridge.mm"],
        "codeSnippets": [
          "// C++ Core\ncv::Mat swapFace(...) {\n  // ... (Core Algorithm)\n  Mat alignedSourceImage = alignFace(...);\n  // ... (Core Algorithm)\n  transformImage(alignedSourceImage, ...);\n  return resultImage;\n}",
          "// Android (JNI)\nextern \"C\" JNIEXPORT jbyteArray JNICALL\nJava_com_frameeffectsoverlayview_FrameEffectsOverlayView_getSwapFace(...) {\n  // Call C++ Core\n  Mat resultImage = FaceProcessing::swapFace(sourceImage, targetImage, sourcePoints, targetPoints);\n  return result;\n}",
          "// iOS (ObjC++)\n+ (UIImage *)getSwapFace:(UIImage *)sourceImage ... {\n  // Call C++ Core\n  cv::Mat resultMat = FaceProcessing::swapFace(sourceMat, targetMat, srcPoints, tgtPoints);\n  return [self matToUIImageWithOrientation:resultMat ...];\n}"
        ],
        "multiHighlightTerms": [
          ["FaceProcessing::swapFace", "alignFace", "transformImage"],
          ["Java_com_frameeffectsoverlayview_FrameEffectsOverlayView_getSwapFace", "FaceProcessing::swapFace"],
          ["getSwapFace", "FaceProcessing::swapFace"]
        ],
        "codeSnippetTableLabels": ["C++ Core", "Android JNI", "iOS ObjC++"],
        "solution": {
          "approach": "C++ Core + Platform Bridge (JNI/ObjC)",
          "details": [
            "C++: Implemented core algorithms and image processing via OpenCV",
            "Android: Bridged Kotlin to C++ via JNI",
            "iOS: Directly invoked C++ logic through Objective-C++",
            "Platform Layer: Only responsible for data conversion (ARGB ‚Üî BGRA) and coordinate mapping"
          ],
          "result": "Achieved 80%+ C++ code reuse, reducing the development cycle by 50%",
          "category": "Cross-platform"
        }
      }
    ],
    "architecture": {
      "title": "3-Layer Modular Architecture",
      "layers": [
        {
          "name": "React Native (UI Layer)",
          "icon": "üì±",
          "responsibilities": ["Custom Fabric Real-time Preview", "Frame Processor Worklets"]
        },
        {
          "name": "Kotlin / Objective-C (Platform Layer)",
          "icon": "üîß",
          "responsibilities": [
            "ML Kit Face Detection",
            "Camera Frame Management",
            "Color Channel Conversion (ARGB ‚Üî BGRA)"
          ]
        },
        {
          "name": "C++ (Algorithm Layer, 80% Reuse)",
          "icon": "‚öôÔ∏è",
          "responsibilities": [
            "OpenCV Processing (Geometry/Blending)",
            "Delaunay Triangulation",
            "Core Face Swap Algorithms"
          ]
        }
      ]
    },
    "gallery": {
      "tabs": {
        "demo": "Demo",
        "screenshots": "Development Screenshots"
      },
      "demo": {
        "v1": {
          "title": "Android Demo",
          "desc": "Real-time face swap effect on Android"
        },
        "v2": {
          "title": "iOS Demo",
          "desc": "Real-time face swap effect on iOS"
        }
      },
      "screenshots": {
        "s1": {
          "title": "Face Swap Effect - Example 1",
          "desc": "Visual result of the face swap algorithm"
        },
        "s2": {
          "title": "Face Swap Effect - Example 2",
          "desc": "Visual result of the face swap algorithm"
        }
      }
    },
    "disclaimer": "This is a Proof of Concept (PoC) project demonstrating the technical feasibility of real-time image processing. All media assets shown are for demonstration purposes only."
  }
}
