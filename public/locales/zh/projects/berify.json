{
  "shortDesc": "整合 NFC 與 MPC 的 Web3 RWA 虛實整合平台",
  "technologies": ["React Native", "Swift App Clips", "Next.js", "Node.js", "Prisma", "Shopify API", "Web3"],
  "role": "軟體開發者",
  "achievements": [],
  "detail": {
    "hero": {
      "title": "Berify",
      "tagline": "分散式 O2O 生態系統 · 微服務架構",
      "statusBadge": "正式上線中"
    },
    "overview": {
      "description": "專注於 React Native 基礎設施，並協作整合 Web 端流程，負責原生層的穩定性維護與版本升級，並主導 Rewards 獎勵模組的完整重構與解耦，並協作維護 IDV 身分驗證模組。",
      "duration": "2023 - 2024 (1 年 5 個月)",
      "team": "8 人團隊合作",
      "projectType": "商業產品",
      "mainTechs": ["React Native", "Swift App Clips", "Next.js", "Node.js", "Prisma", "Shopify API", "Web3"],
      "platforms": ["iOS", "Android", "Web"]
    },
    "architectureFlow": {
      "title": "系統架構鏈路",
      "steps": [
        { "step": "1", "title": "App (NFC 掃描)", "desc": "React Native & Swift App Clip", "metric": "觸發交互" },
        { "step": "2", "title": "App-Backend", "desc": "Web3 & API Gateway", "metric": "業務邏輯" },
        { "step": "3", "title": "Berify-DB & Queue", "desc": "排程服務 & 任務佇列", "metric": "異步處理" },
        { "step": "4", "title": "WebSocket & SNS", "desc": "即時通知與雲端推播", "metric": "雙向回饋" }
      ]
    },
    "architectureMetrics": {
      "title": "核心工程與貢獻",
      "list": [
        {
          "title": "模組化規模",
          "metric": "9 個分散式服務單元 / 188+ 領域模型",
          "desc": ["設計並主導三層式收藏體系，並與電商平台實現數據對接", "整合生物辨識 IDV 安全體系"]
        },
        {
          "title": "資料演進",
          "metric": "114+ 次資料庫架構演進歷程",
          "desc": ["設計扁平化留言模型，避免 N+1 查詢問題", "透過 Prisma Schema 強型別約束，維護高頻遷移一致性"]
        },
        {
          "title": "原生層穩定性",
          "metric": "跨平台環境標準化",
          "desc": ["排除核心模組編譯衝突，穩定原生建置環境", "解決 App Clip 視圖殘留異常"]
        }
      ]
    },
    "technicalSpotlight": [
      {
        "id": "app-clip",
        "title": "App Clip 導航修正：解決畫面殘留與狀態管理",
        "role": "iOS 原生技術負責人",
        "icon": "smartphone",
        "summary": "修復掃描流程導航死鎖問題，提升使用者體驗",
        "tags": ["iOS Native", "State Reset", "NFC Optimization"],
        "challenge": {
          "title": "挑戰",
          "items": [
            "在使用 App Clip 連續進行 NFC 觸發時，仍然顯示前次掃描的結果頁面",
            "此現象導致用戶在實體場景操作中斷，直接影響掃描轉換率"
          ]
        },
        "analysis": {
          "title": "分析與工具",
          "items": [
            "查閱 SceneDelegate 與根視圖控制器的邏輯",
            "追蹤 UIViewController 的 presented 狀態鏈條，確認系統無法自動重置 Modal Presentation"
          ]
        },
        "decisions": {
          "title": "工程決策",
          "items": [
            {
              "title": "方案評估：如何重置導航狀態？",
              "items": [
                {
                  "title": "更新彈窗內容",
                  "desc": "缺點：需要考慮多個狀態，例如：加載中、動畫播放中、失敗、成功等"
                },
                {
                  "title": "透過遞迴尋找最上層控制器，並強制關閉",
                  "desc": "優點：可以重置視圖狀態，確保生命週期一致性",
                  "highlight": true
                }
              ]
            }
          ]
        },
        "result": {
          "title": "結果",
          "items": ["消除 UI 衝突導致的導航阻斷", "提升使用者掃描到查看商品頁面的流暢度"]
        },
        "codeSnippetTabs": [
          {
            "label": "Main Logic",
            "title": "原生 UI 堆疊清理邏輯",
            "language": "swift",
            "code": "// 透過遞迴 dismiss 確保每次掃描都能從初始的 Landing 狀態啟動\nfunc useLandingController() -> LandingViewController? {\n  let keyWindow = UIApplication.shared.windows.filter {\n    $0.isKeyWindow\n  }.first\n\n  if var topController = keyWindow?.rootViewController {\n    while let presented = \n      topController.presentedViewController {\n      topController = presented\n    }\n\n    if topController is ScanResultViewController ||\n       topController is ScanErrorViewController {\n        topController.dismiss(animated: false)\n    }\n  }\n  return keyWindow?.rootViewController as? LandingViewController\n}",
            "highlights": [8, 9, 10, 13, 14, 15],
            "tooltips": [
              { "line": 8, "content": "遞迴查找最上層 Presented VC" },
              { "line": 13, "content": "僅針對特定視圖類型執行清理" },
              { "line": 15, "content": "強制移除殘留視窗" }
            ]
          }
        ]
      },
      {
        "id": "optimize-and-refactor-rewards",
        "title": "獎勵系統重構：實現跨模組視差滾動與狀態同步",
        "role": "模組架構負責人",
        "icon": "smartphone",
        "summary": "結合 Module-Scoped Context 與 CustomFlatList 泛型封裝，建立標準化的動畫狀態流，解決複雜嵌套滾動衝突並確保跨頁面 UI 與數據的精確同步",
        "tags": ["React Context", "Custom Hook Encapsulation"],
        "challenge": {
          "title": "挑戰",
          "items": ["跨頁面數據未同步，點數顯示錯誤頻發引發客訴", "標準組件無法支撐複雜視差，導致滾動體驗嚴重卡頓"]
        },
        "decisions": {
          "title": "工程決策",
          "items": [
            {
              "title": "決策一：狀態管理方案選型 - 解決多源數據同步問題",
              "items": [
                {
                  "title": "構建模組級 Context State，自動廣播狀態變更",
                  "desc": "優點：Context 能在不增加額外 bundle size 的前提下解決局部狀態共享問題，且符合當下的架構",
                  "highlight": true
                },
                {
                  "title": "引入 Redux 或 React Query 集中管理伺服器狀態",
                  "desc": "缺點：當前專案架構並沒有設計 Redux，引入會增加額外的架構複雜度"
                }
              ]
            },
            {
              "title": "決策二：視差滾動方案選型 - 解決複雜視差滾動問題",
              "items": [
                {
                  "title": "CustomFlatList (自訂封裝)",
                  "desc": "優點：結合 Content Padding 與 Native Driver，達成流暢的視差滾動",
                  "highlight": true
                },
                {
                  "title": "ScrollView",
                  "desc": "缺點：全量渲染導致主線程阻塞，無法支撐長列表效能"
                },
                {
                  "title": "FlatList",
                  "desc": "缺點：標準 Header 耦合滾動流，無法實現視差縮放與圖層分離"
                },
                {
                  "title": "Reanimated + FlatList",
                  "desc": "缺點：不符合當前專案架構"
                }
              ]
            }
          ]
        },
        "showcase": {
          "alt": "展示 CustomFlatList 的視差滾動效果"
        },
        "result": {
          "title": "結果",
          "items": [
            "統一跨頁面狀態管理，解決點數顯示錯誤引發的客訴問題",
            "突破原生組件限制，完美還原設計師要求的高複雜度視差體驗"
          ]
        },
        "codeSnippetTabs": [
          {
            "label": "Logic & Context",
            "title": "原生驅動視差滾動：Context 狀態流與插值運算",
            "language": "typescript",
            "code": "// 1. 在 Context 中定義原生動畫插值 (Interpolation)\nconst styles = useMemo(() => ({\n  background: {\n    transform: [\n      {\n        translateY: scrollY.interpolate({\n          inputRange: [0, headerHeight],\n          outputRange: [0, -headerHeight]\n        })\n      },\n      {\n        scale: scrollY.interpolate({\n          inputRange: [-windowHeight, 0],\n          outputRange: [4.2, 1]\n        })\n      }\n    ]\n  }\n}), [scrollY, headerHeight]);\n\nconst onScroll = Animated.event(\n  [{ nativeEvent: { contentOffset: { y: scrollY } } }],\n  { useNativeDriver: true }\n);",
            "highlights": [6, 7, 8, 12, 13, 14, 23],
            "tooltips": [
              { "line": 6, "content": "計算 Parallax 位移：隨滾動向上移動背景，創造層次感" },
              { "line": 12, "content": "計算 Scale 縮放：下拉時放大背景圖，模擬原生 iOS 彈性效果" },
              { "line": 23, "content": "啟用 useNativeDriver：將計算卸載至 UI 線程，確保幀率穩定" }
            ]
          },
          {
            "label": "Component View",
            "title": "原生驅動視差滾動：Context 狀態流與插值運算",
            "language": "typescript",
            "code": "// 2. 在 UI 層消費 Context 並綁定動畫\nfunction CustomFlatList({ children, BackgroundComponent }) {\n  const { styles, onScroll } = useCustomFlatListContext();\n  return (\n    <Stack>\n      <Animated.View style={[styles.background]} pointerEvents='box-none'>\n        {BackgroundComponent}\n      </Animated.View>\n      <Animated.FlatList\n        onScroll={onScroll}\n        scrollEventThrottle={16}\n        {...props}\n      />\n    </Stack>\n  );\n}",
            "highlights": [10],
            "tooltips": [{ "line": 10, "content": "綁定 Animated.event：直接連結 ScrollView 偏移量與 Animated.Value" }]
          }
        ]
      }
    ],
    "gallery": {
      "tabs": {
        "consumerApp": "消費者體驗",
        "merchantDashboard": "商家管理"
      },
      "consumerApp": {
        "home": { "title": "首頁", "desc": "NFC 產品驗證入口" },
        "productDetail": { "title": "產品詳情", "desc": "區塊鏈驗證資訊與 NFT 資產" },
        "chat": { "title": "即時互動", "desc": "WebSocket 品牌聊天室" },
        "rewards": { "title": "獎勵中心", "desc": "Shopify 折扣碼同步" },
        "rewardsDetail": { "title": "獎勵詳情", "desc": "點數兌換專屬折扣" },
        "notifications": { "title": "通知中心", "desc": "AWS SNS 推播" },
        "profile": { "title": "個人檔案", "desc": "個人檔案" },
        "scanHistory": { "title": "掃描歷程", "desc": "產品互動記錄" }
      },
      "merchantDashboard": {
        "dashboard": { "title": "儀表板", "desc": "多維度分析" },
        "inventory": { "title": "庫存管理", "desc": "數位標籤管理" },
        "experience": { "title": "體驗管理", "desc": "跨分店數位體驗" },
        "experienceDetail": { "title": "體驗詳情", "desc": "抽獎規則與 NFT 內容" },
        "rewards": { "title": "獎勵策略", "desc": "O2O 促銷規則" },
        "account": { "title": "權限管理", "desc": "細粒度角色與存取" }
      }
    },
    "disclaimer": "本頁面展示的內容為商業專案，相關截圖僅供作品集展示用途。"
  }
}
