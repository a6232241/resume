{
  "profile": {
    "greeting": "你好，我是蔡寬程",
    "bio": "我是一位專注手機應用開發的前端工程師，擁有超過四年 React Native 經驗，同時擅長使用 Next.js 開發 Web。",
    "companiesIntro": "我曾任職或合作過的公司包括"
  },
  "section": {
    "workProjects": "工作專案",
    "personalProjects": "個人專案",
    "experience": "經歷",
    "skills": "技能",
    "workExperience": "工作經驗",
    "about": "關於"
  },
  "projects": {
    "musicPlayer": {
      "shortDesc": "這是一個音樂播放器 App，讓使用者輕鬆收聽音樂。",
      "technologies": ["Expo", "React Native", "SQLite", "Node.js", "Express.js"],
      "fullDesc": "這款音樂播放器 App 支援本地儲存音樂列表，確保離線也能播放，並提供歌手、音樂類別、名稱等多條件篩選功能。\n\n開發初衷是解決市面音樂播放器缺乏篩選機制，以及網路不穩導致播放中斷的痛點。\n\n技術棧：Expo 開發框架、SQLite 本地資料庫、Node.js + Express.js 後端備份。未來計畫整合 Google Drive 等雲端服務，提升使用者體驗。",
      "detail": {
        "hero": {
          "title": "音樂播放器 App",
          "tagline": "離線播放與智慧篩選"
        },
        "overview": {
          "duration": "2 個月",
          "team": "個人開發",
          "projectType": "個人專案",
          "mainTechs": ["Expo", "React Native", "SQLite", "Node.js", "Express.js"],
          "platforms": ["Android", "iOS"]
        }
      }
    },
    "visualStreaming": {
      "shortDesc": "在直播預覽中即時替換臉部，驗證高效能影像處理與原生整合可行性。",
      "technologies": ["React Native", "Vision Camera", "Kotlin/ObjC", "C++", "OpenCV"],
      "achievements": [
        "單人 4 個月完成 Android/iOS 雙平台 Demo",
        "C++ 代碼複用率 80%+，跨平台共用核心邏輯",
        "採用 RN 新架構 Fabric & TurboModules，開發 Native Component"
      ],
      "role": "單人 · 4 個月",
      "fullDesc": "一個 React Native 全棧項目：在直播應用中實現實時人臉交換特效。核心挑戰是在無深度學習模型訓練的前提下，用傳統幾何影像處理完成概念驗證，同時確保跨平台相容性。\n\n技術亮點：\n• React Native + Vision Camera 實時預覽與自訂 Frame Processor 設計\n• 原生層集成 ML Kit 人臉檢測，解決感測器幀與相機預覽的座標偏差問題\n• Kotlin ↔ C++（OpenCV）直接通訊，C++ 代碼在 iOS 端複用率達 80%+\n\n4 個月獨立完成 Android/iOS 雙平台 Demo，涵蓋前端、原生、算法的完整技術棧整合。",
      "detail": {
        "hero": {
          "title": "Visual Streaming",
          "tagline": "實時直播換臉特效 PoC"
        },
        "overview": {
          "duration": "4 個月",
          "team": "獨立開發",
          "projectType": "PoC 探索性項目",
          "mainTechs": [
            "React Native",
            "Kotlin/ObjC",
            "C++",
            "OpenCV",
            "Vision Camera",
            "Fabric & TurboModules",
            "ML Kit"
          ],
          "platforms": ["Android", "iOS"]
        },
        "motivation": {
          "title": "為什麼做這個項目？",
          "description": "想驗證『在移動設備上實現實時人臉交換』是否可行。",
          "keyQuestions": [
            "實時影像處理能否在手機上跑？",
            "前端（RN）+ 後端（原生）如何高效協作？",
            "跨平台代碼（C++）的複用成本有多低？"
          ]
        },
        "challenges": [
          {
            "title": "座標轉換與設備適配",
            "symptom": "人臉特徵點位置與預覽畫面不對齊",
            "rootCause": "透過 Vision Camera 的預覽畫面與 frame 的座標系統不一致",
            "impact": "人臉交換效果位置錯亂"
          },
          {
            "title": "計算性能瓶頸",
            "symptom": "人臉檢測導致 UI 卡頓",
            "rootCause": "ML Kit 人臉檢測是耗時操作，在主執行緒進行會阻塞渲染",
            "impact": "用戶體驗卡頓，交互不流暢"
          },
          {
            "title": "跨平台開發成本",
            "symptom": "代碼重複、維護複雜",
            "rootCause": "Android/iOS 分別實現導致 2 倍工作量",
            "impact": "項目周期拉長"
          }
        ],
        "solutions": [
          {
            "problem": "座標轉換與設備適配",
            "approach": "自定義影像繪製邏輯",
            "details": [
              "捕獲 Vision Camera 的 frame.orientation 獲取設備當前方向",
              "使用 Matrix.postRotate() 應用設備旋轉補償",
              "根據相機位置（前/後）應用對應的矩陣變換（翻轉/無翻轉）",
              "在 Canvas 繪製時應用最終變換矩陣"
            ],
            "result": "人臉檢測點與屏幕預覽完全對齊，支持各種設備方向",
            "category": "座標映射"
          },
          {
            "problem": "計算性能瓶頸",
            "approach": "異步處理 + 結果快取",
            "details": [
              "使用 Kotlin Coroutines 的 Dispatchers.IO 在後台執行 FaceDetector",
              "人臉檢測結果快取在成員變數中",
              "渲染層直接使用快取結果，避免重複計算",
              "SurfaceView 直接繪製，減少 View 層級開銷"
            ],
            "result": "UI 執行緒主要進行 Canvas 繪製，計算密集工作在後台進行",
            "category": "性能優化"
          },
          {
            "problem": "跨平台開發成本",
            "approach": "C++ 代碼複用",
            "details": [
              "Canvas 複雜變形效能不足",
              "OpenCV 提供更優化的算法",
              "C++ 可在 iOS/Android 上複用，降低開發成本"
            ],
            "result": "80%+ C++ 代碼複用，開發周期減少 50%",
            "category": "跨平台"
          }
        ],
        "architecture": {
          "title": "三層模組化架構",
          "layers": [
            {
              "name": "React Native（UI 層）",
              "responsibilities": ["Vision Camera 實時預覽"]
            },
            {
              "name": "Kotlin / Objective-C（Platform 層）",
              "responsibilities": ["ML Kit 人臉檢測", "相機幀數據管理", "色彩通道轉換（ARGB ↔ BGRA）"]
            },
            {
              "name": "C++（算法層，80% 複用）",
              "responsibilities": ["OpenCV 圖像處理 (幾何變換/融合)", "Deluanay 三角剖分", "人臉交換"]
            }
          ]
        },
        "metrics": {
          "accuracy": {
            "title": "座標映射精準度",
            "before": "特徵點位置錯亂",
            "after": "視覺上完全對齊",
            "improvement": "從錯誤 → 正確"
          },
          "performance": {
            "title": "渲染流暢度",
            "before": "頻繁卡頓",
            "after": "基本流暢（接近實時）",
            "improvement": "從卡頓 → 可用"
          },
          "development": {
            "cpp_reuse_rate": "80%+",
            "timeline": "4 個月"
          }
        },
        "learnings": [
          {
            "title": "系統瓶頸 vs 代碼瓶頸",
            "category": "架構設計",
            "description": "學會識別『架構瓶頸』而非『代碼瓶頸』，用架構優化而非代碼優化來解決性能問題"
          },
          {
            "title": "掌握完整鏈路",
            "category": "跨層整合",
            "description": "從 React Native → Kotlin/Objective-C → C++ 的完整技術棧整合經驗"
          },
          {
            "title": "複用策略",
            "category": "跨平台設計",
            "description": "80%+ C++ 複用不是偶然，需要前期架構設計考慮跨平台性"
          }
        ]
      }
    },
    "aiChatApp": {
      "shortDesc": "使用 GitHub Models 提供 AI 對話功能，並使用 SQLite 進行本地數據存儲，確保用戶的聊天記錄安全且可離線訪問",
      "technologies": ["Expo", "React Native", "GitHub Models", "SQLite"],
      "fullDesc": "這款 AI 聊天 App 專為學習 AI 而建，使用者可建立多聊天室、保留對話記憶，並隨時刪除歷史紀錄。\n\n技術棧：Expo 開發框架，整合 GitHub Models 實現 AI 對話功能。",
      "detail": {
        "hero": {
          "title": "AI 聊天 App",
          "tagline": "多房間 AI 對話記憶"
        },
        "overview": {
          "duration": "1 個月",
          "team": "個人開發",
          "projectType": "學習專案",
          "mainTechs": ["Expo", "React Native", "GitHub Models"],
          "platforms": ["Android", "iOS"]
        }
      }
    },
    "10xAppSpeed": {
      "title": "10x App Speed",
      "shortDesc": "主導深度架構重構，成功將載入耗時降低 90%，並建立全域狀態管理規範。",
      "technologies": ["React Native", "Redux Toolkit", "React Query", "React DevTools", "Flipper"],
      "fullDesc": "針對一款登入流程出現嚴重效能瓶頸(耗時達 10 秒)的應用程式,我主導了從「診斷、評估到重構」的全流程優化。透過 Flipper 與 React DevTools 定位出全域重複渲染(Re-render)與 API 狀態頻繁重置的核心問題。在評估了維護成本與風險後,我決定升級 Redux Toolkit 並導入 createSelector 緩存機制,最終成功將登入耗時降低 90%,並大幅提升了多頁面導航的流暢度。",
      "badge": "-90% 延遲時間",
      "detail": {
        "hero": {
          "title": "10x App Speed: Performance Optimization",
          "tagline": "登入流程 × 多頁面導航 × 狀態管理",
          "challenge": {
            "title": "挑戰 (Challenge)",
            "desc": "解決登入 <highlight>10s</highlight> 延遲與白屏卡頓。"
          },
          "solution": {
            "title": "方案 (Solution)",
            "desc": "重構 Redux 緩存機制並升級 RTK。"
          },
          "impact": {
            "title": "成效 (Impact)",
            "desc": "提速 <highlight>90%</highlight> (<highlight>10x</highlight>)，改善導航流暢度。"
          }
        },
        "overview": {
          "duration": "2 週",
          "team": "獨立診斷與優化",
          "projectType": "工作專案 · 性能優化",
          "mainTechs": "React Native, Redux Toolkit, React Query, React DevTools, Flipper",
          "focus": "登入流程, 多頁面導航, 狀態管理",
          "metrics": {
            "login": {
              "area": "登入流程",
              "exp": "有效解決了原本用戶在登入後常見的白屏與操作卡頓感"
            },
            "nav": {
              "area": "多頁面導航",
              "exp": "顯著降低了 QA 階段的性能投訴率"
            }
          }
        },
        "diagnosis": {
          "steps": {
            "qa": { "title": "QA 反饋", "desc": "App 性能瓶頸投訴", "finding": "QA 反饋登入後頁面卡頓超過 10 秒" },
            "api": { "title": "API 檢測", "finding": "排除後端問題，確認瓶頸在前端" },
            "render": { "title": "渲染分析", "finding": "發現登入後的重複重置導致全域 re-render" },
            "state": { "title": "狀態檢查", "finding": "定位到兩處重複調用 resetApiState 加重 re-render 的次數" }
          },
          "findings": {
            "cascade": {
              "title": "跨頁面級聯重新渲染",
              "symptom": "登入後所有使用 useQuery 的頁面受影響",
              "metric": "無關頁面被渲染多次"
            },
            "reset": {
              "title": "重複執行 resetApiState",
              "symptom": "登入後執行兩次，加重渲染問題",
              "loc1": "登入按鈕完成後",
              "loc2": "Token 成功後"
            },
            "select": {
              "title": "selectFromResult 過度計算",
              "symptom": "每次 store 變化都重新執行，缺乏記憶化",
              "impact": "導致淺比較失敗，觸發不必要重新渲染"
            }
          }
        },
        "solutions": {
          "title": "解決方案評估",
          "approaches": {
            "source": {
              "name": "修改 RTK Query 源代碼",
              "risk": "🔴 高",
              "maintainability": "低",
              "tradeoff": "成本過高，維護困難"
            },
            "skip": {
              "name": "全局啟用 Skip 邏輯",
              "risk": "🟡 中",
              "maintainability": "中",
              "tradeoff": "每次切頁需手動刷新"
            },
            "selector": {
              "name": "CreateSelector 優化",
              "risk": "🟢 低",
              "maintainability": "高",
              "decision": "✅ 先選",
              "reason": "安全的優化路線"
            },
            "upgrade": {
              "name": "升級 Redux Toolkit",
              "risk": "🟡 中",
              "maintainability": "高",
              "decision": "✅ 最終",
              "result": "效果超出預期"
            }
          }
        },
        "implementation": {
          "phases": {
            "p1": {
              "title": "登入流程狀態管理優化",
              "duration": "2-3 天",
              "steps": "分析與驗證,代碼分離並優化,識別重複 resetApiState,決定移除其中一個調用,完整流程驗證測試",
              "keyChangeType": "移除重複調用",
              "keyChangeRemoved": "handleLogin() 中的 resetApiState()"
            },
            "p2": {
              "title": "多頁面導航性能優化",
              "duration": "1-2 週",
              "steps": "RTK Query 源代碼分析,識別 selectFromResult 過度計算,評估 4 個解決方案,實施 createSelector 優化,升級 Redux Toolkit,與 QA 協同測試",
              "change1": "createSelector 優化",
              "impact1": "明確依賴追蹤",
              "change2": "Redux 升級",
              "impact2": "根本性能提升"
            },
            "p3": {
              "title": "訂閱同步問題修復",
              "duration": "1 天",
              "issue": "升級後數據獲取過快導致訂閱前被刪除",
              "solution": "調整操作順序：導航前清理 vs 進入後清理",
              "result": "數據完整性確保 ✅"
            }
          }
        },
        "evidence": {
          "videos": {
            "v1": {
              "title": "登入流程優化 (前)",
              "desc": "登入流程優化前的實機畫面",
              "watch": "注意時間 00:23 處，登入後頁面載入的白屏時間"
            },
            "v2": {
              "title": "登入流程優化 (後)",
              "desc": "登入流程優化後的實機畫面",
              "watch": "注意時間 00:15 處，登入後頁面載入的白屏時間"
            },
            "v5": {
              "title": "多頁面導航 createSelector 優化 (前)",
              "desc": "添加 createSelector 前的實機畫面",
              "watch": "注意導航切換後，頁面載入的白屏時間"
            },
            "v6": {
              "title": "多頁面導航 createSelector 優化 (後)",
              "desc": "添加 createSelector 後的實機畫面",
              "watch": "注意導航切換後，頁面載入的白屏時間"
            },
            "v7": {
              "title": "多頁面導航 Redux Toolkit 升級 (前)",
              "desc": "Redux Toolkit 升級前的直播列表頁面導航",
              "watch": "注意每次導航切換後，頁面載入的白屏時間"
            },
            "v8": {
              "title": "多頁面導航 Redux Toolkit 升級 (後)",
              "desc": "Redux Toolkit 升級後的直播列表頁面導航",
              "watch": "注意每次導航切換後，頁面載入的白屏時間"
            },
            "v9": { "title": "聊天室訂閱同步問題修復 (前)", "desc": "數據丟失問題" },
            "v10": { "title": "聊天室訂閱同步問題修復 (後)", "desc": "數據完整性確保", "result": "數據完整 ✅" }
          },
          "screenshots": {
            "s1": {
              "title": "定位重複 API 重置邏輯",
              "shows": "通過分析發現 handleLogin 與 Token 更新時重複調用 resetApiState，加重重複渲染問題"
            },
            "s2": {
              "title": "createSelector 記憶化重構",
              "shows": "將 selectFromResult 使用 createSelector 重構，確保僅在相關數據變更時才觸發組件重新渲染"
            },
            "s3": {
              "title": "狀態同步時序修正",
              "shows": "修正導航與數據清理的執行順序，解決在高頻更新場景下的數據丟失問題"
            },
            "s4": { "title": "登入流程火焰圖 (前)", "shows": "登入流程優化前的渲染火焰圖" },
            "s5": { "title": "登入流程火焰圖 (後)", "shows": "登入流程優化後的渲染火焰圖" },
            "s10": { "title": "登入流程 Flipper 狀態監控 (前)", "shows": "登入流程優化前的 Flipper 狀態變化" },
            "s11": { "title": "登入流程 Flipper 狀態監控 (後)", "shows": "登入流程優化後的 Flipper 狀態變化" },
            "s6": {
              "title": "多頁面導航 createSelector 優化 (前）",
              "shows": "添加 createSelector 前的多頁面導航火焰圖"
            },
            "s7": {
              "title": "多頁面導航 createSelector 優化 (後）",
              "shows": "添加 createSelector 後的多頁面導航火焰圖"
            },
            "s8": { "title": "多頁面導航 Redux Toolkit 升級 (前）", "shows": "Redux Toolkit 升級前的多頁面導航火焰圖" },
            "s9": { "title": "多頁面導航 Redux Toolkit 升級 (後）", "shows": "Redux Toolkit 升級後的多頁面導航火焰圖" }
          },
          "references": {
            "r1": { "desc": "selectFromResult 過度重新渲染社區討論" }
          }
        },
        "insights": {
          "i1": {
            "title": "Redux 全局更新的級聯效應",
            "summary": "理解 store 變更引發全應用重新渲染的防禦機制",
            "concept": "Redux store 任何改變都會通知所有訂閱者",
            "impact": "導致全應用級的連鎖重新渲染",
            "solution": "組件層加防護（React.memo、選擇器記憶化）",
            "key": "架構設計決定性能上限"
          },
          "i2": {
            "title": "SelectFromResult 反模式",
            "summary": "解決緩存失效主因：缺乏記憶化導致的無效淺比較",
            "concept": "沒有記憶化的選擇器在每次 store 變化都重新執行",
            "impact": "缺乏依賴追蹤，導致過度重新渲染",
            "key": "依賴管理是性能優化的核心"
          },
          "i3": {
            "title": "狀態同步時序問題",
            "summary": "掌握非同步操作順序對邏輯正確性的影響",
            "concept": "非同步操作的順序決定了邏輯的正確性",
            "impact": "升級依賴改變性能特性，暴露原有缺陷",
            "lesson": "充分測試、明確操作順序",
            "key": "優化與重構需要系統思維"
          },
          "i4": {
            "title": "系統化的性能診斷方法",
            "summary": "建立一套標準的排除 API、確認渲染、定位根因流程",
            "methodology": "排除 API → 確認渲染 → 定位根因",
            "benefit": "快速定位複雜問題",
            "key": "工具 and 方法論一樣重要"
          },
          "i5": {
            "title": "依賴升級的風險管理",
            "summary": "平衡升級帶來的收益與潛在的性能特性變化風險",
            "challenge": "升級有風險但不升級有遺憾",
            "approach": "充分評估 → 謹慎嘗試 → 完整驗證",
            "outcome": "通常能帶來超出預期的收益",
            "key": "計算化風險管理推動進步"
          },
          "i6": {
            "title": "社區知識的價值",
            "summary": "利用 GitHub Issues 驗證方案，加速核心瓶頸定位",
            "resource": "GitHub Issues 是快速獲取知識和驗證方案的途徑",
            "example": "Issue #4028 驗證了性能問題的根本原因",
            "practice": "積極參與、主動分享",
            "key": "社區知識加速個人成長"
          }
        }
      }
    },
    "berify": {
      "shortDesc": "協助商家管理商品與會員，透過 Web3 提供可驗證的數位資產與行銷工具。",
      "technologies": ["React Native", "Swift App Clips", "Next.js", "Web3"],
      "role": "核心開發 · React Native 主應用",
      "achievements": [],
      "fullDesc": "Web3 智慧零售完整生態系統。商家透過後台管理與分析商品，消費者掃描產品標籤以解鎖商品資訊、特別促銷、NFT 和贈品功能，並整合第三方錢包查看資產。\n\n技術棧：React Native 主應用、Swift App Clips 掃描功能、Next.js 後端伺服器與完整 CMS。",
      "detail": {
        "hero": {
          "title": "Berify",
          "tagline": "Web3 智慧零售生態系統"
        },
        "overview": {
          "duration": "1 年",
          "team": "核心開發",
          "projectType": "商業產品",
          "mainTechs": ["React Native", "Swift App Clips", "Next.js", "Web3"],
          "platforms": ["Android", "iOS", "Web"]
        }
      }
    },
    "sourceCode": "原始碼",
    "storeLink": "商店"
  },
  "nav": {
    "back": "返回"
  }
}
